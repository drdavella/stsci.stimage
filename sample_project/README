Overview
----------
In previous versions of stsci_python, projects were build using the 'distutils'
system in the Python standard library.  Projects built this way use the
familiar setup.py scripts for building and installation, as well as to specify
any metadata about the project.

In stsci_python in particular, though setup.py was used, we had some additional
machinery that required all the normal setup.py parameters to be stored in a
separate script called defsetup.py.  Rather than feed arguments directly to
the setup() function as is typical for setup.py scripts, in defsetup.py the
arguments to setup() were set in a dictionary that was then fed into the
setup() function.  That made it easier for other utilities to access the
project's metadata without actually having to execute setup().

In this version of stsci_python, the defsetup.py files have been removed.
Instead, a new system is used that's based on distribute plus a system that
will allow forward-compatibility with distutils2/packaging, the next-generation
build/ distribution system for Python.

Bear with me while I give a little background on Python packaging.  For the
last decade or so it has been a wild frontier, and it is only due to very
recent efforts that it's becoming standardized again and reconsolidated.  So if
you're not already familiar with the terms involved, it can get very confusing
(feel free to skip the next section if you are familiar).

Background
============
While distutils [1]_ has been part of the Python standard library for a long
time, it's had a number of acknolwedged deficiencies since the beginning, and
is not often used by itself anymore.

A number of years ago a system called 'setuptools' became very popular.  It is
built on top of distutils and works more or less the same way (a setup.py
script written for plain distutils will work with setuptools as well).
However, setuptools added a number of improvements.  Chief among these is that
it keeps track of the *versions* of each package you have installed, and can
even support having multiple versions installed simulataneously.  This also
enables dependency management:  Whenever a new package is installed, setuptools
will ensure that you have all its dependencies (including the correct versions)
installed.  If not, it will automatically download (from PyPI or an alternate)
and install any needed dependencies.

setuptools quickly became the more or less de-facto system for Python
packaging, and many if not most Python projects out there rely on it.  The
familiar tools easy_install and pip [2]_ are built around the setuptools
system (easy_install actually comes as an integral component of setuptools).

However, in the last two years it's been slowly replaced by something called
'distribute' [3]_.  distribute is actually a *fork* of setuptools, and was
started due to disagreements between the setuptools developer and others
interested in Python packaging.  distribute still actually uses the name
'setuptools' internally, and is designed to just be a drop-in replacement for
setuptools.

Anything built with setuptools will work the same in distribute, but distribute
tries to fix some of the basic problems with setuptools.  So sometimes the
names distribute and setuptools are used interchangeably--they refer to roughly
the same thing.

But it's been long considered that there are other intractable problems
inherent in the distutils+setuptools/distribute stack that can't be fixed
without more radical changes.

For example, the setup() function is considered a bad idea, in part due to the
problem that stsci_python's defsetup.py files tries to solve:  It's impossible
to get metadata from a project that uses it without actually running the
setup.py script (unless it happens to include a pre-built PKG-INFO file, which
most projects don't).

Another problem is that much of how setuptools works is not based on any
standard accepted by the Python core developers, or community at large.  So for
some time there were increased calls for a new community-approved packaging
standard that could be rallied around, and hopefully solve many of the old
warts of distutils+setuptools.

Enter distutils2 [4]_: distutils2 is the Guido-blessed effort to redo Python
packaging based on some updated standards, taking into account much of what's
been learned over the last several years.  Under the covers, distutils2 still
looks a lot like distutils in many areas, but it's significantly cleaned up,
many of the warts are removed, and it incorporates some of the most useful
functionaltiy from setuptools/distribute.

The biggest noticeable change in distutils2 is that setup.py is gone.  Instead,
all downloading/building/installation of Python packages is done with a program
called pysetup.  Meanwhile, individual projects specify their metadata in a
plain text file called setup.cfg.  The biggest advantage to this is that all
the project's metadata can be read without having to execute any Python code.

It should be noted that this is not as much a limitation as it sounds like:
distutils2 still supports hooks in various places for running code.  For
example, in your setup.cfg you can specify the name of a pre-build hook to
execute before the build command is run.  But the important point is that this
pre-build code *only* runs where applicable.  One can still read the setup.cfg
file without executing any code.

distutils2 was recently merged into the Python standard library, and will be
included in Python 3.3, though a standalone version will be made available for
use with older Python versions.  Just make things even more confusing, when it
was merged into the standard library it was renamed simply "packaging" [5]_.
So distutils2=packaging and vice-versa.  Throughout the rest of this document I
will continue to refer to it as "distutils2" (or d2 for short) for two reasons:
I started using it before it was renamed "packaging", and it's also just a less
ambiguous and overloaded term.


How things work now
---------------------
stsci_python projects now use distribute.  The main advantage to this is
managing the dependencies between packages.  I've worked out, for the most
part, what all these dependencies are and added them to each project's
metadata.  For now, it's very strict about version numbers, so that even if
someone only installs one or two packages from stsci_python, we can still have
some assurance of what versions they're using for the dependencies.

stsci_python itself is now sort of a meta-project that has all its sub-projects
as its dependencies.  So installing stsci_python will just install everything
it depends on.

There's an additional layer on top of this that's quite unique.  I rather like
how distutils2 does things, and I wanted to look ahead to its eventual release
(at which point it will be promoted as the "best practice" for Python
packaging).  In particular, I like its use of the plain-text setup.cfg files to
describe a project.  However, we do not want to actually depend on distutils2
yet: it is far too unstable, and does not yet support all the features we need.

The solution to this is a utility called d2to1 [6]_, which is a compatibility
layer between distutils2-style setup.cfgs, and distutils/distribute setup.py
scripts.  Essentially, it takes the contents of a setup.cfg file and does the
necessary conversions so that it can supply parameters to the setup() function
in a setup.py script.  So installation, for example, is still done by running
`./setup.py install`.  But the actual setup.py is just a bootstrap for dto1,
and all the real information about the project is in setup.cfg.

Using this d2to1 approach is still optional--one can write a normal distribute
setup.py script if desired.  But using d2to1 adds a certain amount of future-
compatibility.  It's designed so that once distutils2/packaging is released,
it can be used to install our projects without too many changes (if any changes
*are* necessary at all they're likely to be in some of the hook scripts).

I've also included a new module to stsci_python called stsci.distutils.  It can
act as a central place to collect these hook scripts so that many projects can
take advantage of them.  For example, most of the packages in stsci_python
require numpy to build, and contain some common code related to using numpy.
In some cases that code has been copy/pasted, and in other cases the same thing
has been reimplemented over and over again.  stsci.distutils includes a hook
function called `numpy_extension_hook` that takes care of all the particulars
of using numpy, including adding the correct include paths and warning the user
if numpy is not installed.

It should also be noted that distutils2/packaging includes functionality for
generating a setup.py file from a setup.cfg file.  I don't know how well it
works yet, but eventually we can switch away from using d2to1 to using this
functionality.  In the meantime, d2to1 is more robust and more certain to work
(in part since I'm maintaining it).


How to add a new project to stsci_python
------------------------------------------

The easiest way to start may be to copy this sample project.  The sample
setup.cfg is a good place to start for configuring the project's metadata.  You
can also read setup.cfg.sample for more information on the options that go in
setup.cfg.


	setup.py
        The setup.py is a boilerplate to bootstrap the d2to1 hooks and pass
        the contents of your setup.cfg file into the normal distutils setup()
        call.  In most cases this file should just be directly copied.

	lib/
        Put all the python code for your package here.  Individual modules may
        be placed directly under lib/, though packages must be contained in a
        directory under lib/ with the same name as the package.  Furthermore,
        to include a package in the stsci namespace it must be under lib/stsci,
        and the proper lib/stsci/__init__.py file must be present.

        NOTE: lib/stsci/__init__.py is not empty!  It must contain special code
        to define the namespace package, and may not contain any other code.
        See the layout of sample_package for an example.

    lib/<package_name>/tests/
        If you want tests to be installed with the package itself, it is
        recommended that they be stored as a subpackage.  For example,
        sample_package.tests.  Make sure to list sample_package.tests in the
        'packages' option in setup.cfg, and to add an __init__.py file in
        lib/<package_name>/tests/

	data/
        You can include data files to be installed.  You can put the data
        anywhere (as long as you list it properly in the data_files option in
        setup.cfg.  If the data is to be installed with a Python package, it is
        recommended instead that it be stored under lib/package_name/data_dir,
        and defined with the package_data option in setup.cfg.

    scripts/
        Place any standalone scripts in here.  Technically they can go anywhere
        as long as the correct path is given in setup.cfg.

	src/
        You can include modules written in C.  Put them here, and include
        defintions in setup.cfg.

--

In Python, a "script" is a piece of code intended to be run directly
from the command line.  The name normally does _not_ end with ".py".

distutils installs scripts in a bin/ directory that is (should be)
on the user's PATH.  The user can just type the name of the script:

	fitsdiff a.fits b.fits

Your script should begin with a line that says:

#! python

When you install the package, distutils will insert the correct
full path of the python interpreter.

In principle, the rest of the script can be any valid python code,
but it is convenient to just import a function from your package
and call it.  For example,

	#! python
	import sample_package.main
	sample_package.main.run()

In stsci_python, you can only write scripts in python; because we
also run on MS Windows, you cannot count on any other scripting
languages (e.g. sh, csh) to be available.


tests
--

If you would like tests that are installed with your package, do
it this way:

Make a directory here named "tests" (with "s" at the end of the name).
(Do not name it "test" - that name conflicts with the test() function
that we will define.)

In tests/__init__.py, put
	from __future__ import division

In tests/test_*.py, put your tests.  Read tests/README.txt for notes on
standards that you must conform to for your tests to work.

Add these lines to __init__.py:

	def test(*args,**kwds):
	    import pytools.tester
	    pytools.tester.test(modname=__name__, *args, **kwds)

After installing your tests, the user can run them by:

	>>> import your_package
	>>> your_package.test()

You can run them with

	% nosetests tests
or
	% pdkrun tests

but of course you must install your package so that the tests can find it.


References
------------
.. [1] http://docs.python.org/library/distutils.html
.. [2] http://www.pip-installer.org
.. [3] http://packages.python.org/distribute
.. [4] http://distutils2.notmyidea.org/index.html
.. [5] http://tarekziade.wordpress.com/2011/05/22/packaging-has-landed-in-the-stdlib
.. [6] http://pypi.python.org/pypi/d2to1
