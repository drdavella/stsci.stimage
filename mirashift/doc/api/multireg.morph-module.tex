%
% API Documentation for ImageShift
% Module multireg.morph
%
% Generated by epydoc 2.1
% [Thu Dec 15 12:26:52 2005]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{multireg.morph \textit{(module)}|(}
\section{Module multireg.morph}

    \label{multireg:morph}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{multireg:morph:closehole}
    \index{multireg.morph \textit{(module)}!closehole \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{closehole}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Close holes of binary and gray-scale images.
- Synopsis
    y = closehole(f, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: (same datatype of f ).
- Description
    mmclohole creates the image y by closing the holes of the image
    f , according with the connectivity defined by the structuring
    element Bc .The images can be either binary or gray-scale.
- Examples
    \#
    \#   example 1
    \#
    a = mmreadgray('pcb1bin.tif')
    b = closehole(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 2
    \#
    a = mmreadgray('boxdrill-B.tif')
    b = closehole(a)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:closing_by_recon}
    \index{multireg.morph \textit{(module)}!closing\_by\_recon \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{closing\_by\_recon}(\textit{image}, \textit{size}=\texttt{3\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Implements closing by reconstruction of size n of image as defined on 
    p. 211, P. Soille, 2002.

    closing = recon\_by\_erosion (dilation(image,size),image)

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:gauss}
    \index{multireg.morph \textit{(module)}!gauss \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{gauss}(\textit{sigma}, \textit{dist})

    \end{boxedminipage}

    \label{multireg:morph:geodesic_dilation}
    \index{multireg.morph \textit{(module)}!geodesic\_dilation \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{geodesic\_dilation}(\textit{marker}, \textit{mask})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Perform geodesic dilation based on algorithm on p. 185 of Soille 
    (2002).

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:geodesic_erosion}
    \index{multireg.morph \textit{(module)}!geodesic\_erosion \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{geodesic\_erosion}(\textit{marker}, \textit{mask})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Perform Geodesic erosion based on algorithm on p. 168, P. Soille, 
    2002.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:geodesic_erosion1d}
    \index{multireg.morph \textit{(module)}!geodesic\_erosion1d \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{geodesic\_erosion1d}(\textit{marker}, \textit{mask})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Perform Geodesic erosion (in 1D) based on algorithm on p. 168, P. 
    Soille, 2002.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:grey_chm_transform}
    \index{multireg.morph \textit{(module)}!grey\_chm\_transform \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{grey\_chm\_transform}(\textit{array}, \textit{fg}, \textit{bg}, \textit{origin}=\texttt{0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Perform Grey-scale constrained-hit-or-miss transform
   based on algorithm from pg. 145, Soille (2002).
   Example based on Fig 5.4 (pg 144, Soille 2002).

Input:
   array: gray-scale array (1-D or 2-D)
   fg   : foreground mask array (UInt8 only)
   bg   : background mask array (UInt8 only)

 Example:
   f = N.array([3, 3, 3, 0, 1, 6, 2, 1, 7, 5, 1, 0, 4, 6, 7, 3, 3, 3], 
               type=Int8)
   B = N.array([0,0,1,1],N.UInt8)
   Bc = N.array([1,1,0,0,1,1],N.UInt8)
   chm = morph.grey\_chm\_transform(f,B,Bc)
   print chm
   array([0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0], type=Int8)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:grey_uhm_transform}
    \index{multireg.morph \textit{(module)}!grey\_uhm\_transform \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{grey\_uhm\_transform}(\textit{array}, \textit{fg}, \textit{bg})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Perform grey-scale unconstrained hit-or-miss transform
based on the algorithm from p 143 of Soille 2002.

Input:
   array: gray-scale array (1-D or 2-D)
   fg   : foreground mask array (UInt8 only)
   bg   : background mask array (UInt8 only)

 Example:
   f = N.array([3, 3, 3, 0, 1, 6, 2, 1, 7, 5, 1, 0, 4, 6, 7, 3, 3, 3], 
               type=Int8)
   B = N.array([0,0,1,1],N.UInt8)
   Bc = N.array([1,1,0,0,1,1],N.UInt8)
   chm = morph.grey\_uchm\_transform(f,B,Bc)
   print chm
   array([0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0], type=Int8)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:limits}
    \index{multireg.morph \textit{(module)}!limits \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{limits}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Get the possible minimum and maximum of an image.
- Synopsis
    y = limits(f)
- Input
    f: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Output
    y: Vector, the first element is the infimum, the second, the
       supremum.
- Description
    The possible minimum and the possible maximum of an image depend
    on its data type. These values are important to compute many
    morphological operators (for instance, negate of an image). The
    output is a vector, where the first element is the possible
    minimum and the second, the possible maximum.
- Examples
    \#
    print limits(mmbinary([0, 1, 0]))
    print limits(uint8([0, 1, 2]))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:makegauss}
    \index{multireg.morph \textit{(module)}!makegauss \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{makegauss}(\textit{shape}, \textit{sigma}, \textit{norm})

    \end{boxedminipage}

    \label{multireg:morph:numneg}
    \index{multireg.morph \textit{(module)}!numneg \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{numneg}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Negate an image.
- Synopsis
    y = numneg(f)
- Input
    f: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmneg returns an image y that is the negation (i.e., inverse or
    involution) of the image f . In the binary case, y is the
    complement of f .
- Examples
    \#
    \#   example 1
    \#
    f=uint8([255, 255, 0, 10, 20, 10, 0, 255, 255])
    print numneg(f)
    print numneg(uint8([0, 1]))
    print numneg(int32([0, 1]))
    \#
    \#   example 2
    \#
    a = mmreadgray('gear.tif')
    b = nummneg(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 3
    \#
    c = mmreadgray('astablet.tif')
    d = nummneg(c)
    mmshow(c)
    mmshow(d)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:opening_by_recon}
    \index{multireg.morph \textit{(module)}!opening\_by\_recon \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{opening\_by\_recon}(\textit{image}, \textit{size}=\texttt{3\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Implements opening by reconstruction of size n of image as defined on 
    p. 210, P. Soille, 2002.

    opening = recon\_by\_dilation (erosion(image,size),image)

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:point_maximum}
    \index{multireg.morph \textit{(module)}!point\_maximum \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{point\_maximum}(\textit{array}, \textit{mask})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Return a point-wise maximum array based on the mask image.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:point_minimum}
    \index{multireg.morph \textit{(module)}!point\_minimum \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{point\_minimum}(\textit{array}, \textit{mask})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Return a point-wise minimum array based on the mask image.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:recon_by_dilation}
    \index{multireg.morph \textit{(module)}!recon\_by\_dilation \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{recon\_by\_dilation}(\textit{marker}, \textit{mask}, \textit{max\_iter}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Iterate over geodesic dilation operations
until dilation(j+1) = dilation(j).
Perform Geodesic dilation based on
algorithm on p. 190-191, P. Soille, 2002. 
This can be referenced as:
  R{\textasciicircum}delta\_mask(marker)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:recon_by_erosion}
    \index{multireg.morph \textit{(module)}!recon\_by\_erosion \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{recon\_by\_erosion}(\textit{marker}, \textit{mask}, \textit{max\_iter}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Iterate over geodesic erosion operations
until erosion(j+1) = erosion(j).
Perform Geodesic erosion based on
algorithm on p. 191-192, P. Soille, 2002. 
This can be referenced as:
  R{\textasciicircum}epsilon\_mask(marker)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:transform_concave}
    \index{multireg.morph \textit{(module)}!transform\_concave \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{transform\_concave}(\textit{marker}, \textit{interval}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Perform h-concave transformation using algorithm
specified on pg. 203 of Soille (2002).
The algorithm can be stated as:

    HMIN\_h(f) = recon\_by\_erosion(f+h,f)  
    HCONCAVE\_h(f) = HMIN\_h(f) - f

where f = marker, h = interval.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:morph:transform_convex}
    \index{multireg.morph \textit{(module)}!transform\_convex \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{transform\_convex}(\textit{marker}, \textit{interval}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Perform h-convex transformation using algorithm
specified on pg. 203 of Soille (2002).
The algorithm can be stated as:

    HMAX\_h(f) = recon\_by\_dilation(f+h,f)  
    HCONVEX\_h(f) = f - HMAX\_h(f)

where f = marker, h = interval.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \index{multireg.morph \textit{(module)}|)}
