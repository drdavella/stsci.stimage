%
% API Documentation for ImageShift
% Module multireg.num_pymorph
%
% Generated by epydoc 2.1
% [Thu Dec 15 12:26:52 2005]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{multireg.num\_pymorph \textit{(module)}|(}
\section{Module multireg.num\_pymorph}

    \label{multireg:num_pymorph}
\begin{alltt}
Module morph -- SDC Morphology Toolbox 
    Partially translated to numarray and nd\_image 
    
-------------------------------------------------------------------
The pymorph Morphology Toolbox for Python is a powerful collection of latest
state-of-the-art gray-scale morphological tools that can be applied to image
segmentation, non-linear filtering, pattern recognition and image analysis.
-------------------------------------------------------------------
**********************
*
* Translated to work with numarray
*
**********************
mmadd4dil()      -- Addition for dilation
mmbinary()       -- Convert a gray-scale image into a binary image
mmcwatershed()   -- Detection of watershed from markers.
mmdatatype()     -- Return the image datatype string
mmdil()          -- Dilate an image by a structuring element.
mmdist()         -- Distance transform.
mmero()          -- Erode an image by a structuring element.
mmgray()         -- Convert a binary image into a gray-scale image.
mmhomothin()     -- Interval for homotopic thinning.
mmimg2se()       -- Create a structuring element from a pair of images.
mminterot()      -- Rotate an interval
mmintersec()     -- Intersection of images.
mmis()           -- Verify if a relationship among images is true or false.
mmisbinary()     -- Check for binary image
mmisequal()      -- Verify if two images are equal
mmislesseq()     -- Verify if one image is less or equal another (is
                    beneath)
mmlimits()       -- Get the possible minimum and maximum of an image.
mmmat2set()      -- Converts image representation from matrix to set
mmmaxleveltype() -- Returns the maximum value associated to an image
                    datatype
mmneg()          -- Negate an image.
mmse2hmt()       -- Create a Hit-or-Miss Template (or interval) from a pair
                    of structuring elements.
mmsecross()      -- Diamond structuring element and elementary 3x3 cross.
mmseline()       -- Create a line structuring element.
mmsereflect()    -- Reflect a structuring element
mmserot()        -- Rotate a structuring element.
mmsesum()        -- N-1 iterative Minkowski additions
mmset2mat()      -- Converts image representation from set to matrix
mmsetrans()      -- Translate a structuring element
mmseunion()      -- Union of structuring elements
mmsubm()         -- Subtraction of two images, with saturation.
mmsupgen()       -- Sup-generating (hit-miss).
mmunion()        -- Union of images.

int32()          -- Convert an image to an int32 image.
uint8()          -- Convert an image to an uint8 image.
uint16()         -- Convert an image to a uint16 image.


**********************
*
* Original form based on Numeric
*
**********************
mmaddm()         -- Addition of two images, with saturation.
mmareaclose()    -- Area closing
mmareaopen()     -- Area opening
mmasf()          -- Alternating Sequential Filtering
mmasfrec()       -- Reconstructive Alternating Sequential Filtering
mmbench()        -- benchmarking main functions of the toolbox.
mmblob()         -- Blob measurements from a labeled image.
mmbshow()        -- Generate a graphical representation of overlaid binary
                    images.
mmcbisector()    -- N-Conditional bisector.
mmcdil()         -- Dilate an image conditionally.
mmcenter()       -- Center filter.
mmcero()         -- Erode an image conditionally.
mmclohole()      -- Close holes of binary and gray-scale images.
mmclose()        -- Morphological closing.
mmcloserec()     -- Closing by reconstruction.
mmcloserecth()   -- Close-by-Reconstruction Top-Hat.
mmcloseth()      -- Closing Top Hat.
mmcmp()          -- Compare two images pixelwisely.
mmconcat()       -- Concatenate two or more images along width, height or
                    depth.
mmcthick()       -- Image transformation by conditional thickening.
mmcthin()        -- Image transformation by conditional thinning.
mmdrawv()        -- Superpose points, rectangles and lines on an image.
mmdtshow()       -- Display a distance transform image with an iso-line
                    color table.
mmedgeoff()      -- Eliminate the objects that hit the image frame.
mmendpoints()    -- Interval to detect end-points.
mmflood()        -- Flooding filter- h,v,a-basin and dynamics (depth, area,
                    volume)
mmframe()        -- Create a frame image.
mmfreedom()      -- Control automatic data type conversion.
mmgdist()        -- Geodesic Distance Transform.
mmgdtshow()      -- Apply an iso-line color table to a gray-scale image.
mmglblshow()     -- Apply a random color table to a gray-scale image.
mmgradm()        -- Morphological gradient.
mmgrain()        -- Gray-scale statistics for each labeled region.
mmgshow()        -- Apply binary overlays as color layers on a binary or
                    gray-scale image
mmhistogram()    -- Find the histogram of the image f.
mmhmax()         -- Remove peaks with contrast less than h.
mmhmin()         -- Remove basins with contrast less than h.
mmhomothick()    -- Interval for homotopic thickening.
mminfcanon()     -- Intersection of inf-generating operators.
mminfgen()       -- Inf-generating.
mminfrec()       -- Inf-reconstruction.
mminpos()        -- Minima imposition.
mminstall()      -- Verify if the Morphology Toolbox is registered.
mmintershow()    -- Visualize an interval.
mmlabel()        -- Label a binary image.
mmlabelflat()    -- Label the flat zones of gray-scale images.
mmlastero()      -- Last erosion.
mmlblshow()      -- Display a labeled image assigning a random color for
                    each label.
mmopen()         -- Morphological opening.
mmopenrec()      -- Opening by reconstruction.
mmopenrecth()    -- Open-by-Reconstruction Top-Hat.
mmopenth()       -- Opening Top Hat.
mmopentransf()   -- Open transform.
mmpad4n()        -- mmpad4n
mmpatspec()      -- Pattern spectrum (also known as granulometric size
                    density).
mmplot()         -- Plot a function.
mmreadgray()     -- Read an image from a commercial file format and stores
                    it as a gray-scale image.
mmregister()     -- Register the SDC Morphology Toolbox.
mmregmax()       -- Regional Maximum.
mmregmin()       -- Regional Minimum (with generalized dynamics).
mmse2interval()  -- Create an interval from a pair of structuring elements.
mmsebox()        -- Create a box structuring element.
mmsedil()        -- Dilate one structuring element by another
mmsedisk()       -- Create a disk or a semi-sphere structuring element.
mmseshow()       -- Display a structuring element as an image.
mmshow()         -- Display binary or gray-scale images and optionally
                    overlay it with binary images.
mmskelm()        -- Morphological skeleton (Medial Axis Transform).
mmskelmrec()     -- Morphological skeleton reconstruction (Inverse Medial
                    Axis Transform).
mmskiz()         -- Skeleton of Influence Zone - also know as Generalized
                    Voronoi Diagram
mmstats()        -- Find global image statistics.
mmsupcanon()     -- Union of sup-generating or hit-miss operators.
mmsuprec()       -- Sup-reconstruction.
mmswatershed()   -- Detection of similarity-based watershed from markers.
mmsymdif()       -- Symmetric difference between two images
mmtext()         -- Create a binary image of a text.
mmthick()        -- Image transformation by thickening.
mmthin()         -- Image transformation by thinning.
mmthreshad()     -- Threshold (adaptive)
mmtoggle()       -- Image contrast enhancement or classification by the
                    toggle operator.
mmvdome()        -- Obsolete, use mmvmax.
mmversion()      -- SDC Morphology Toolbox version.
mmvmax()         -- Remove domes with volume less than v.
mmwatershed()    -- Watershed detection.

---\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{multireg:num_pymorph:int32}
    \index{multireg.num\_pymorph \textit{(module)}!int32 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{int32}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Convert an image to an int32 image.

      \item Synopsis img = int32(f)

      \item Input f: Any image

      \item Output img: The converted image

      \item Description int32 clips the input image between the values 
        -2147483647 and 2147483647 and converts it to the signed 32-bit 
        datatype.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmadd4dil}
    \index{multireg.num\_pymorph \textit{(module)}!mmadd4dil \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmadd4dil}(\textit{f}, \textit{c})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Addition for dilation

      \item Synopsis a = mmadd4dil(f, c)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. Image c: 
        Gray-scale (uint8 or uint16) or binary image. Constant

      \item Output a: Image f + c

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmaddm}
    \index{multireg.num\_pymorph \textit{(module)}!mmaddm \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmaddm}(\textit{f1}, \textit{f2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Addition of two images, with saturation.
- Synopsis
    y = mmaddm(f1, f2)
- Input
    f1: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image.
    f2: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image. Or constant.
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmaddm creates the image y by pixelwise addition of images f1
    and f2 . When the addition of the values of two pixels saturates
    the image data type considered, the greatest value of this type
    is taken as the result of the addition.
- Examples
    \#
    \#   example 1
    \#
    f = uint8([255,   255,    0,   10,    0,   255,   250])
    g = uint8([ 0,    40,   80,   140,  250,    10,    30])
    y1 = mmaddm(f,g)
    print y1
    y2 = mmaddm(g, 100)
    print y2
    \#
    \#   example 2
    \#
    a = mmreadgray('keyb.tif')
    b = mmaddm(a,128)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmareaclose}
    \index{multireg.num\_pymorph \textit{(module)}!mmareaclose \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmareaclose}(\textit{f}, \textit{a}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Area closing
- Synopsis
    y = mmareaclose(f, a, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image.
    a:  Double non negative integer.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: Same type of f
- Description
    mmareaclose removes any pore (i.e., background connected
    component) with area less than a of a binary image f . The
    connectivity is given by the structuring element Bc . This
    operator is generalized to gray-scale images by applying the
    binary operator successively on slices of f taken from higher
    threshold levels to lower threshold levels.
- Examples
    \#
    \#   example 1
    \#
    a=mmreadgray('form-1.tif')
    b=mmareaclose(a,400)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 2
    \#
    a=mmreadgray('n2538.tif')
    b=mmareaclose(a,400)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmareaopen}
    \index{multireg.num\_pymorph \textit{(module)}!mmareaopen \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmareaopen}(\textit{f}, \textit{a}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Area opening
- Synopsis
    y = mmareaopen(f, a, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image.
    a:  Double non negative integer.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: Same type of f
- Description
    mmareaopen removes any grain (i.e., connected component) with
    area less than a of a binary image f . The connectivity is given
    by the structuring element Bc . This operator is generalized to
    gray-scale images by applying the binary operator successively
    on slices of f taken from higher threshold levels to lower
    threshold levels.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary(uint8([
     [1, 1, 0, 0, 0, 0, 1],
     [1, 0, 1, 1, 1, 0, 1],
     [0, 0, 0, 0, 1, 0, 0]]))
    y=mmareaopen(f,4,mmsecross())
    print y
    \#
    \#   example 2
    \#
    f=uint8([
       [10,   11,   0,    0,   0,   0,  20],
       [10,    0,   5,    8,   9,   0,  15],
       [10,    0,   0,    0,  10,   0,   0]])
    y=mmareaopen(f,4,mmsecross())
    print y
    \#
    \#   example 3
    \#
    a=mmreadgray('form-1.tif');
    b=mmareaopen(a,500);
    mmshow(a);
    mmshow(b);
    \#
    \#   example 4
    \#
    a=mmreadgray('bloodcells.tif');
    b=mmareaopen(a,500);
    mmshow(a);
    mmshow(b);\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmasf}
    \index{multireg.num\_pymorph \textit{(module)}!mmasf \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmasf}(\textit{f}, \textit{SEQ}=\texttt{'\-O\-C\-'\-}, \textit{b}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Alternating Sequential Filtering

      \item Synopsis y = mmasf(f, SEQ="OC", b=None, n=1)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. SEQ: 
        String Default: "OC". 'OC', 'CO', 'OCO', 'COC'. b: Structuring 
        Element Default: None (3x3 elementary cross). n: Non-negative 
        integer. Default: 1. (number of iterations).

      \item Output y: Image

      \item Description mmasf creates the image y by filtering the image f by 
        n iterations of the close and open alternating sequential filter 
        characterized by the structuring element b . The sequence of 
        opening and closing is controlled by the parameter SEQ . 'OC' 
        performs opening after closing, 'CO' performs closing after 
        opening, 'OCO' performs opening after closing after opening, and 
        'COC' performs closing after opening after closing.

      \item Examples \# \# example 1 \# f=mmreadgray('gear.tif') 
        g=mmasf(f,'oc',mmsecross(),2) mmshow(f) mmshow(g) \# \# example 2 
        \# f=mmreadgray('fabric.tif') g=mmasf(f,'oc',mmsecross(),3) 
        mmshow(f) mmshow(g)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmasfrec}
    \index{multireg.num\_pymorph \textit{(module)}!mmasfrec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmasfrec}(\textit{f}, \textit{SEQ}=\texttt{'\-O\-C\-'\-}, \textit{b}=\texttt{N\-o\-n\-e\-}, \textit{bc}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Reconstructive Alternating Sequential Filtering

      \item Synopsis y = mmasfrec(f, SEQ="OC", b=None, bc=None, n=1)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. SEQ: 
        String Default: "OC". Values: "OC" or "CO". b: Structuring 
        Element Default: None (3x3 elementary cross). bc: Structuring 
        Element Default: None (3x3 elementary cross). n: Non-negative 
        integer. Default: 1. (number of iterations).

      \item Output y: Same type of f

      \item Description mmasf creates the image y by filtering the image f by 
        n iterations of the close by reconstruction and open by 
        reconstruction alternating sequential filter characterized by the 
        structuring element b . The structure element bc is used in the 
        reconstruction. The sequence of opening and closing is controlled 
        by the parameter SEQ . 'OC' performs opening after closing, and 
        'CO' performs closing after opening.

      \item Examples \# f=mmreadgray('fabric.tif') 
        g=mmasfrec(f,'oc',mmsecross(),mmsecross(),3) mmshow(f) mmshow(g)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmbench}
    \index{multireg.num\_pymorph \textit{(module)}!mmbench \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmbench}(\textit{count}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    benchmarking main functions of the toolbox.
- Synopsis
    mmbench(count=10)
- Input
    count: Double Default: 10. Number of repetitions of each
           function.

- Description
    mmbench measures the speed of many of SDC Morphology Toolbox
    functions in seconds. An illustrative example of the output of
    mmbench is, for a MS-Windows 2000 Pentium 4, 2.4GHz, 533MHz
    system bus, machine: SDC Morphology Toolbox V1.2 27Sep02
    Benchmark Made on Wed Jul 16 15:33:17 2003 computer= win32 image
    filename= csample.jpg width= 640 , height= 480 Function time
    (sec.) 1. Union bin 0.00939999818802 2. Union gray-scale
    0.00319999456406 3. Dilation bin, mmsecross 0.0110000014305 4.
    Dilation gray, mmsecross 0.00780000686646 5. Dilation gray,
    non-flat 3x3 SE 0.0125 6. Open bin, mmsecross 0.0125 7. Open
    gray-scale, mmsecross 0.0141000032425 8. Open gray, non-flat 3x3
    SE 0.0235000014305 9. Distance mmsecross 0.021899998188 10.
    Distance Euclidean 0.0264999985695 11. Geodesic distance
    mmsecross 0.028100001812 12. Geodesic distance Euclidean
    0.303100001812 13. Area open bin 0.0639999985695 14. Area open
    gray-scale 0.148500001431 15. Label mmsecross 0.071899998188 16.
    Regional maximum, mmsecross 0.043700003624 17. Open by rec,
    gray, mmsecross 0.0515000104904 18. ASF by rec, oc, mmsecross, 1
    0.090600001812 19. Gradient, gray-scale, mmsecross
    0.0171999931335 20. Thinning 0.0984999895096 21. Watershed
    0.268799996376 Average 0.0632523809161\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmbinary}
    \index{multireg.num\_pymorph \textit{(module)}!mmbinary \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmbinary}(\textit{f}, \textit{k1}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Convert a gray-scale image into a binary image
- Synopsis
    y = mmbinary(f, k1=1)
- Input
    f:  Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image.
    k1: Double Default: 1. Threshold value.
- Output
    y: Binary image.
- Description
    mmbinary converts a gray-scale image f into a binary image y by
    a threshold rule. A pixel in y has the value 1 if and only if
    the corresponding pixel in f has a value greater or equal k1 .
- Examples
    \#
    \#   example 1
    \#
    a = array([0, 1, 2, 3, 4])
    b=mmbinary(a)
    print b
    \#
    \#   example 2
    \#
    a=mmreadgray('mm3.tif')
    b=mmbinary(a,82)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmblob}
    \index{multireg.num\_pymorph \textit{(module)}!mmblob \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmblob}(\textit{fr}, \textit{measurement}, \textit{option}=\texttt{'\-i\-m\-a\-g\-e\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Blob measurements from a labeled image.
- Synopsis
    y = mmblob(fr, measurement, option="image")
- Input
    fr:          Gray-scale (uint8 or uint16) image. Labeled image.
    measurement: String Default: "". Choice from 'AREA', 'CENTROID',
                 or 'BOUNDINGBOX'.
    option:      String Default: "image". Output format: 'image':
                 results as a binary image; 'data': results a column
                 vector of measurements (double).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    Take measurements from the labeled image fr . The measurements
    are: area, centroid, or bounding rectangle. The parameter option
    controls the output format: 'IMAGE': the result is an image;
    'DATA': the result is a double column vector with the
    measurement for each blob. The region with label zero is not
    measured as it is normally the background. The measurement of
    region with label 1 appears at the first row of the output.
- Examples
    \#
    \#   example 1
    \#
    fr=uint8([
       [1,1,1,0,0,0],
       [1,1,1,0,0,2],
       [1,1,1,0,2,2]])
    f\_area=mmblob(fr,'area')
    print f\_area
    f\_cent=mmblob(fr,'centroid')
    print f\_cent
    f\_bb=mmblob(fr,'boundingbox')
    print f\_bb
    d\_area=mmblob(fr,'area','data')
    print d\_area
    d\_cent=mmblob(fr,'centroid','data')
    print d\_cent
    d\_bb=mmblob(fr,'boundingbox','data')
    print d\_bb
    \#
    \#   example 2
    \#
    f=mmreadgray('blob3.tif')
    fr=mmlabel(f)
    g=mmblob(fr,'area')
    mmshow(f)
    mmshow(g)
    \#
    \#   example 3
    \#
    f=mmreadgray('blob3.tif')
    fr=mmlabel(f)
    centr=mmblob(fr,'centroid')
    mmshow(f,mmdil(centr))
    \#
    \#   example 4
    \#
    f=mmreadgray('blob3.tif')
    fr=mmlabel(f)
    box=mmblob(fr,'boundingbox')
    mmshow(f,box)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmbshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmbshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmbshow}(\textit{f1}, \textit{f2}=\texttt{N\-o\-n\-e\-}, \textit{f3}=\texttt{N\-o\-n\-e\-}, \textit{factor}=\texttt{1\-7\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Generate a graphical representation of overlaid binary images.
- Synopsis
    y = mmbshow(f1, f2=None, f3=None, factor=17)
- Input
    f1:     Binary image.
    f2:     Binary image. Default: None.
    f3:     Binary image. Default: None.
    factor: Double Default: 17. Expansion factor for the output
            image. Use odd values above 9.
- Output
    y: Binary image. shaded image.
- Description
    Generate an expanded binary image as a graphical representation
    of up to three binary input images. The 1-pixels of the first
    image are represented by square contours, the pixels of the
    optional second image are represented by circles and for the
    third image they are represented by shaded squares. This
    function is useful to create graphical illustration of small
    images.
- Examples
    \#
    f1=mmtext('b')
    f2=mmtext('w')
    g2=mmbshow(f1,f2)
    mmshow(g2)
    f3=mmtext('x')
    g3=mmbshow(f1,f2,f3)
    mmshow(g3);\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcbisector}
    \index{multireg.num\_pymorph \textit{(module)}!mmcbisector \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcbisector}(\textit{f}, \textit{B}, \textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose N-Conditional bisector.

      \item Synopsis y = mmcbisector(f, B, n)

      \item Input f: Binary image. B: Structuring Element n: positive integer 
        ( filtering rate)

      \item Output y: Binary image.

      \item Description mmcbisector creates the binary image y by performing 
        a filtering of the morphological skeleton of the binary image f , 
        relative to the structuring element B . The strength of this 
        filtering is controlled by the parameter n. Particularly, if n=0 
        , y is the morphological skeleton of f itself.

      \item Examples \# a=mmreadgray('blob2.tif') 
        b=mmcbisector(a,mmsebox(),1) c=mmcbisector(a,mmsebox(),3) 
        d=mmcbisector(a,mmsebox(),10) mmshow(a,b) mmshow(a,c) mmshow(a,d)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcdil}
    \index{multireg.num\_pymorph \textit{(module)}!mmcdil \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcdil}(\textit{f}, \textit{g}, \textit{b}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Dilate an image conditionally.
- Synopsis
    y = mmcdil(f, g, b=None, n=1)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    g: Gray-scale (uint8 or uint16) or binary image. Conditioning
       image.
    b: Structuring Element Default: None (3x3 elementary cross).
    n: Non-negative integer. Default: 1. (number of iterations).
- Output
    y: Image
- Description
    mmcdil creates the image y by dilating the image f by the
    structuring element b conditionally to the image g . This
    operator may be applied recursively n times.
- Examples
    \#
    \#   example 1
    \#
    f = mmbinary(uint8([[1, 0, 0, 0, 0, 0, 0],                [0, 0, 0, 0, 0, 0, 0],                [0, 0, 0, 0, 1, 0, 0,]]))
    g = mmbinary(uint8([[1, 1, 1, 0, 0, 1, 1],                [1, 0, 1, 1, 1, 0, 0],                [0, 0, 0, 0, 1, 0, 0]]));
    y1=mmcdil(f,g,mmsecross())
    y2=mmcdil(f,g,mmsecross(),3)
    \#
    \#   example 2
    \#
    f = uint8([                [   0,    0,   0,   80,   0,   0],                [   0,    0,   0,    0,   0,   0],                [  10,   10,   0,  255,   0,   0]])
    g = uint8([                [   0,    1,   2,   50,   4,   5],                [   2,    3,   4,    0,   0,   0],                [  12,  255,  14,   15,  16,  17]])
    y1=mmcdil(f,g,mmsecross())
    y2=mmcdil(f,g,mmsecross(),3)
    \#
    \#   example 3
    \#
    g=mmreadgray('pcb1bin.tif')
    f=mmframe(g,5,5)
    y5=mmcdil(f,g,mmsecross(),5)
    y25=mmcdil(f,g,mmsecross(),25)
    mmshow(g)
    mmshow(g,f)
    mmshow(g,y5)
    mmshow(g,y25)
    \#
    \#   example 4
    \#
    g=mmneg(mmreadgray('n2538.tif'))
    f=mmintersec(g,0)
    f=mmdraw(f,'LINE:40,30,60,30:END')
    y1=mmcdil(f,g,mmsebox())
    y30=mmcdil(f,g,mmsebox(),30)
    mmshow(g)
    mmshow(f)
    mmshow(y1)
    mmshow(y30)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcenter}
    \index{multireg.num\_pymorph \textit{(module)}!mmcenter \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcenter}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Center filter.

      \item Synopsis y = mmcenter(f, b=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. b: 
        Structuring Element Default: None (3x3 elementary cross).

      \item Output y: Image

      \item Description mmcenter creates the image y by computing recursively 
        the morphological center, relative to the structuring element b , 
        of the image f .

      \item Examples \# f=mmreadgray('gear.tif') g=mmcenter(f,mmsedisk(2)) 
        mmshow(f) mmshow(g)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcero}
    \index{multireg.num\_pymorph \textit{(module)}!mmcero \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcero}(\textit{f}, \textit{g}, \textit{b}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Erode an image conditionally.
- Synopsis
    y = mmcero(f, g, b=None, n=1)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    g: Gray-scale (uint8 or uint16) or binary image. Conditioning
       image.
    b: Structuring Element Default: None (3x3 elementary cross).
    n: Non-negative integer. Default: 1. (number of iterations).
- Output
    y: Image
- Description
    mmcero creates the image y by eroding the image f by the
    structuring element b conditionally to g . This operator may be
    applied recursively n times.
- Examples
    \#
    f = mmneg(mmtext('hello'))
    mmshow(f)
    g = mmdil(f,mmseline(7,90))
    mmshow(g)
    a1=mmcero(g,f,mmsebox())
    mmshow(a1)
    a13=mmcero(a1,f,mmsebox(),13)
    mmshow(a13)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmclohole}
    \index{multireg.num\_pymorph \textit{(module)}!mmclohole \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmclohole}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Close holes of binary and gray-scale images.
- Synopsis
    y = mmclohole(f, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: (same datatype of f ).
- Description
    mmclohole creates the image y by closing the holes of the image
    f , according with the connectivity defined by the structuring
    element Bc .The images can be either binary or gray-scale.
- Examples
    \#
    \#   example 1
    \#
    a = mmreadgray('pcb1bin.tif')
    b = mmclohole(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 2
    \#
    a = mmreadgray('boxdrill-B.tif')
    b = mmclohole(a)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmclose}
    \index{multireg.num\_pymorph \textit{(module)}!mmclose \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmclose}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Morphological closing.

      \item Synopsis y = mmclose(f, b=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. b: 
        Structuring Element Default: None (3x3 elementary cross).

      \item Output y: Image

      \item Description mmclose creates the image y by the morphological 
        closing of the image f by the structuring element b . In the 
        binary case, the closing by a structuring element B may be 
        interpreted as the intersection of all the binary images that 
        contain the image f and have a hole equal to a translation of B . 
        In the gray-scale case, there is a similar interpretation taking 
        the functions umbra.

      \item Examples \# \# example 1 \# f=mmreadgray('blob.tif') 
        bimg=mmreadgray('blob1.tif') b=mmimg2se(bimg) mmshow(f) 
        mmshow(mmclose(f,b)) mmshow(mmclose(f,b),mmgradm(f)) \# \# 
        example 2 \# f = mmreadgray('form-1.tif') mmshow(f) y = 
        mmclose(f,mmsedisk(4)) mmshow(y) \# \# example 3 \# f = 
        mmreadgray('n2538.tif') mmshow(f) y = mmclose(f,mmsedisk(3)) 
        mmshow(y)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmclose_old}
    \index{multireg.num\_pymorph \textit{(module)}!mmclose\_old \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmclose\_old}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Morphological closing.

      \item Synopsis y = mmclose(f, b=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. b: 
        Structuring Element Default: None (3x3 elementary cross).

      \item Output y: Image

      \item Description mmclose creates the image y by the morphological 
        closing of the image f by the structuring element b . In the 
        binary case, the closing by a structuring element B may be 
        interpreted as the intersection of all the binary images that 
        contain the image f and have a hole equal to a translation of B . 
        In the gray-scale case, there is a similar interpretation taking 
        the functions umbra.

      \item Examples \# \# example 1 \# f=mmreadgray('blob.tif') 
        bimg=mmreadgray('blob1.tif') b=mmimg2se(bimg) mmshow(f) 
        mmshow(mmclose(f,b)) mmshow(mmclose(f,b),mmgradm(f)) \# \# 
        example 2 \# f = mmreadgray('form-1.tif') mmshow(f) y = 
        mmclose(f,mmsedisk(4)) mmshow(y) \# \# example 3 \# f = 
        mmreadgray('n2538.tif') mmshow(f) y = mmclose(f,mmsedisk(3)) 
        mmshow(y)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcloserec}
    \index{multireg.num\_pymorph \textit{(module)}!mmcloserec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcloserec}(\textit{f}, \textit{bdil}=\texttt{N\-o\-n\-e\-}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Closing by reconstruction.
- Synopsis
    y = mmcloserec(f, bdil=None, bc=None)
- Input
    f:    Gray-scale (uint8 or uint16) or binary image.
    bdil: Structuring Element Default: None (3x3 elementary cross).
          (dilation).
    bc:   Structuring Element Default: None (3x3 elementary cross).
          ( connectivity).
- Output
    y: Same type of f .
- Description
    mmcloserec creates the image y by a sup-reconstruction ( with
    the connectivity defined by the structuring element bc ) of the
    image f from its dilation by bdil .
- Examples
    \#
    a = mmreadgray('danaus.tif')
    mmshow(a)
    b = mmcloserec(a,mmsebox(4))
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcloserecth}
    \index{multireg.num\_pymorph \textit{(module)}!mmcloserecth \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcloserecth}(\textit{f}, \textit{bdil}=\texttt{N\-o\-n\-e\-}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Close-by-Reconstruction Top-Hat.
- Synopsis
    y = mmcloserecth(f, bdil=None, bc=None)
- Input
    f:    Gray-scale (uint8 or uint16) or binary image.
    bdil: Structuring Element Default: None (3x3 elementary cross).
          (dilation)
    bc:   Structuring Element Default: None (3x3 elementary cross).
          ( connectivity)
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmcloserecth creates the image y by subtracting the image f of
    its closing by reconstruction, defined by the structuring
    elements bc and bdil .
- Examples
    \#
    a = mmreadgray('danaus.tif')
    mmshow(a)
    b = mmcloserecth(a,mmsebox(4))
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcloseth}
    \index{multireg.num\_pymorph \textit{(module)}!mmcloseth \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcloseth}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Closing Top Hat.
- Synopsis
    y = mmcloseth(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
- Output
    y: Gray-scale (uint8 or uint16) or binary image. (Same type of f
       ).
- Description
    mmcloseth creates the image y by subtracting the image f of its
    morphological closing by the structuring element b .
- Examples
    \#
    a = mmreadgray('danaus.tif')
    mmshow(a)
    b = mmcloseth(a,mmsebox(5))
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcmp}
    \index{multireg.num\_pymorph \textit{(module)}!mmcmp \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcmp}(\textit{f1}, \textit{oper}, \textit{f2}, \textit{oper1}=\texttt{N\-o\-n\-e\-}, \textit{f3}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Compare two images pixelwisely.
- Synopsis
    y = mmcmp(f1, oper, f2, oper1=None, f3=None)
- Input
    f1:    Gray-scale (uint8 or uint16) or binary image.
    oper:  String Default: "". relationship from: '==', '{\textasciitilde}=',
           '{\textless}','{\textless}=', '{\textgreater}', '{\textgreater}='.
    f2:    Gray-scale (uint8 or uint16) or binary image.
    oper1: String Default: None. relationship from: '==', '{\textasciitilde}=',
           '{\textless}','{\textless}=', '{\textgreater}', '{\textgreater}='.
    f3:    Gray-scale (uint8 or uint16) or binary image. Default:
           None.
- Output
    y: Binary image.
- Description
    Apply the relation oper to each pixel of images f1 and f2 , the
    result is a binary image with the same size. Optionally, it is
    possible to make the comparison among three image. It is
    possible to use a constant value in place of any image, in this
    case the constant is treated as an image of the same size as the
    others with all pixels with the value of the constant.
- Examples
    \#
    \#   example 1
    \#
    print mmcmp(uint8([1, 2, 3]),'{\textless}', uint8(2))
    print mmcmp(uint8([1, 2, 3]),'{\textless}', uint8([0, 2, 4]))
    print mmcmp(uint8([1, 2, 3]),'==', uint8([1, 1, 3]))
    \#
    \#   example 2
    \#
    f=mmreadgray('keyb.tif')
    fbin=mmcmp(uint8(10), '{\textless}', f, '{\textless}', uint8(50))
    mmshow(f)
    mmshow(fbin)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmconcat}
    \index{multireg.num\_pymorph \textit{(module)}!mmconcat \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmconcat}(\textit{DIM}, \textit{X1}, \textit{X2}, \textit{X3}=\texttt{N\-o\-n\-e\-}, \textit{X4}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Concatenate two or more images along width, height or depth.
- Synopsis
    Y = mmconcat(DIM, X1, X2, X3=None, X4=None)
- Input
    DIM: String Dimension to concatenate. 'WIDTH' or 'W', 'HEIGHT'
         or 'H', or ' DEPTH' or 'D'.
    X1:  Gray-scale (uint8 or uint16) or binary image.
    X2:  Gray-scale (uint8 or uint16) or binary image.
    X3:  Gray-scale (uint8 or uint16) or binary image. Default:
         None.
    X4:  Gray-scale (uint8 or uint16) or binary image. Default:
         None.
- Output
    Y: Gray-scale (uint8 or uint16) or binary image.
- Description
    Concatenate two or more images in any of the dimensions: width,
    height or depth. If the images do not match the dimension, a
    larger image is create with zero pixels to accommodate them. The
    images must have the same datatype.
- Examples
    \#
    f1=mmreadgray('cameraman.tif')
    f2=mmreadgray('blob.tif')
    g=mmconcat('W',f1,mmgray(mmneg(f2)))
    mmshow(g);\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcthick}
    \index{multireg.num\_pymorph \textit{(module)}!mmcthick \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcthick}(\textit{f}, \textit{g}, \textit{Iab}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{-\-1\-}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Image transformation by conditional thickening.
- Synopsis
    y = mmcthick(f, g, Iab=None, n=-1, theta=45,
    DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    g:         Binary image.
    Iab:       Interval Default: None (mmhomothick).
    n:         Non-negative integer. Default: -1. Number of
               iterations.
    theta:     Double Default: 45. Degrees of rotation: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or
               'ANTI-CLOCKWISE'.
- Output
    y: Binary image.
- Description
    mmcthick creates the binary image y by performing a thickening
    of the binary image f conditioned to the binary image g . The
    number of iterations of the conditional thickening is n and in
    each iteration the thickening is characterized by rotations of
    theta of the interval Iab .
- Examples
    \#
    \#   example 1
    \#
    f=mmreadgray('blob2.tif')
    mmshow(f)
    t=mmse2hmt(mmbinary([[0,0,0],[0,0,1],[1,1,1]]),
                              mmbinary([[0,0,0],[0,1,0],[0,0,0]]))
    print mmintershow(t)
    f1=mmthick(f,t,40); \# The thickening makes the image border grow
    mmshow(f1)
    \#
    \#   example 2
    \#
    f2=mmcthick(f,mmneg(mmframe(f)),t,40) \# conditioning to inner pixels
    fn=mmcthick(f,mmneg(mmframe(f)),t) \#pseudo convex hull
    mmshow(f2)
    mmshow(fn,f)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcthin}
    \index{multireg.num\_pymorph \textit{(module)}!mmcthin \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcthin}(\textit{f}, \textit{g}, \textit{Iab}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{-\-1\-}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Image transformation by conditional thinning.
- Synopsis
    y = mmcthin(f, g, Iab=None, n=-1, theta=45,
    DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    g:         Binary image.
    Iab:       Interval Default: None (mmhomothin).
    n:         Non-negative integer. Default: -1. Number of
               iterations.
    theta:     Double Default: 45. Degrees of rotations: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'.
- Output
    y: Binary image.
- Description
    mmcthin creates the binary image y by performing a thinning of
    the binary image f conditioned to the binary image g . The
    number of iterations of the conditional thinning is n and in
    each iteration the thinning is characterized by rotations of
    theta of the interval Iab .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmcwatershed}
    \index{multireg.num\_pymorph \textit{(module)}!mmcwatershed \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmcwatershed}(\textit{f}, \textit{g}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{LINEREG}=\texttt{'\-L\-I\-N\-E\-S\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Detection of watershed from markers.
- Synopsis
    Y = mmcwatershed(f, g, Bc=None, LINEREG="LINES")
- Input
    f:       Gray-scale (uint8 or uint16) image.
    g:       Gray-scale (uint8 or uint16) or binary image. marker
             image: binary or labeled.
    Bc:      Structuring Element Default: None (3x3 elementary
             cross). (watershed connectivity)
    LINEREG: String Default: "LINES". 'LINES' or ' REGIONS'.
- Output
    Y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmcwatershed creates the image y by detecting the domain of the
    catchment basins of f indicated by the marker image g ,
    according to the connectivity defined by Bc . According to the
    flag LINEREG y will be a labeled image of the catchment basins
    domain or just a binary image that presents the watershed lines.
    To know more about watershed and watershed from markers, see
    BeucMeye:93 . The implementation of this function is based on
    LotuFalc:00 . WARNING: There is a common mistake related to the
    marker image g . If this image contains only zeros and ones, but
    it is not a binary image, the result will be an image with all
    ones. If the marker image is binary, you have to set this
    explicitly using the logical function.
- Examples
    \#
    \#   example 1
    \#
    a = uint8([                [10,   10,   10,   10,   10,   10,   10],                [10,    9,    6,   18,    6,    5,   10],                [10,    9,    6,   18,    6,    8,   10],                [10,    9,    9,   15,    9,    9,   10],                [10,    9,    9,   15,   12,   10,   10],                [10,   10,   10,   10,   10,   10,   10]])
    b = mmcmp(a,'==',uint8(6))
    print mmcwatershed(a,b)
    print mmcwatershed(a,b,mmsecross(),'REGIONS')
    \#
    \#   example 2
    \#
    f=mmreadgray('astablet.tif')
    grad=mmgradm(f)
    mark=mmregmin(mmhmin(grad,17))
    w=mmcwatershed(grad,mark)
    mmshow(grad)
    mmshow(mark)
    mmshow(w)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdatatype}
    \index{multireg.num\_pymorph \textit{(module)}!mmdatatype \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdatatype}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Return the image datatype string
- Synopsis
    type = mmdatatype(f)
- Input
    f: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image. Any image
- Output
    type: String String representation of image type: 'binary',
          'uint8', 'uint16' or 'int32'
- Description
    mmdatatype returns a string that identifies the pixel datatype
    of the image f .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdil}
    \index{multireg.num\_pymorph \textit{(module)}!mmdil \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdil}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Dilate an image by a structuring element.
- Synopsis
    y = mmdil(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
- Output
    y: Image
- Description
    mmdil performs the dilation of image f by the structuring
    element b . Dilation is a neighbourhood operator that compares
    locally b with f , according to an intersection rule. Since
    Dilation is a fundamental operator to the construction of all
    other morphological operators, it is also called an elementary
    operator of Mathematical Morphology. When f is a gray-scale
    image, b may be a flat or non-flat structuring element.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0]])
    b=mmbinary([1, 1, 0])
    mmdil(f,b)
    f=uint8([
       [ 0,   1,  2, 50,  4,  5],
       [ 2,   3,  4,  0,  0,  0],
       [12, 255, 14, 15, 16, 17]])
    mmdil(f,b)
    \#
    \#   example 2
    \#
    f=mmbinary(mmreadgray('blob.tif'))
    bimg=mmbinary(mmreadgray('blob1.tif'))
    b=mmimg2se(bimg)
    mmshow(f)
    mmshow(mmdil(f,b))
    mmshow(mmdil(f,b),mmgradm(f))
    \#
    \#   example 3
    \#
    f=mmreadgray('pcb\_gray.tif')
    b=mmsedisk(5)
    mmshow(f)
    mmshow(mmdil(f,b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdil_old}
    \index{multireg.num\_pymorph \textit{(module)}!mmdil\_old \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdil\_old}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Dilate an image by a structuring element.
- Synopsis
    y = mmdil(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
- Output
    y: Image
- Description
    mmdil performs the dilation of image f by the structuring
    element b . Dilation is a neighbourhood operator that compares
    locally b with f , according to an intersection rule. Since
    Dilation is a fundamental operator to the construction of all
    other morphological operators, it is also called an elementary
    operator of Mathematical Morphology. When f is a gray-scale
    image, b may be a flat or non-flat structuring element.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0]])
    b=mmbinary([1, 1, 0])
    mmdil(f,b)
    f=uint8([
       [ 0,   1,  2, 50,  4,  5],
       [ 2,   3,  4,  0,  0,  0],
       [12, 255, 14, 15, 16, 17]])
    mmdil(f,b)
    \#
    \#   example 2
    \#
    f=mmbinary(mmreadgray('blob.tif'))
    bimg=mmbinary(mmreadgray('blob1.tif'))
    b=mmimg2se(bimg)
    mmshow(f)
    mmshow(mmdil(f,b))
    mmshow(mmdil(f,b),mmgradm(f))
    \#
    \#   example 3
    \#
    f=mmreadgray('pcb\_gray.tif')
    b=mmsedisk(5)
    mmshow(f)
    mmshow(mmdil(f,b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdist}
    \index{multireg.num\_pymorph \textit{(module)}!mmdist \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdist}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{METRIC}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Distance transform.
- Synopsis
    y = mmdist(f, Bc=None, METRIC=None)
- Input
    f:      Binary image.
    Bc:     Structuring Element Default: None (3x3 elementary
            cross). (connectivity)
    METRIC: String Default: None. 'EUCLIDEAN', or 'EUC2' for squared
            Euclidean.
- Output
    y: distance image in uint16, or in int32 datatype with EUC2
       option.
- Description
    mmdist creates the distance image y of the binary image f . The
    value of y at the pixel x is the distance of x to the complement
    of f , that is, the distance of x to nearest point in the
    complement of f . The distances available are based on the
    Euclidean metrics and on metrics generated by a a regular graph,
    that is characterized by a connectivity rule defined by the
    structuring element Bc . The implementation of the Euclidean
    algorithm is based on LotuZamp:01 .
- Examples
    \#
    \#   example 1
    \#
    a = mmframe(mmbinary(ones((5,9))),2,4)
    f4=mmdist(a)
    f8=mmdist(a,mmsebox())
    fe=mmdist(a,mmsebox(),'EUCLIDEAN')
    \#
    \#   example 2
    \#
    f = mmreadgray('gear.tif')
    f = mmneg(mmgradm(f))
    d4=mmdist(f)
    d8=mmdist(f,mmsebox())
    de=mmdist(f,mmsebox(),'EUCLIDEAN')
    mmshow(f)
    mmshow(d4\%8)
    mmshow(d8\%8)
    mmshow(de\%8)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdrawv}
    \index{multireg.num\_pymorph \textit{(module)}!mmdrawv \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdrawv}(\textit{f}, \textit{data}, \textit{value}, \textit{GEOM})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Superpose points, rectangles and lines on an image.
- Synopsis
    y = mmdrawv(f, data, value, GEOM)
- Input
    f:     Gray-scale (uint8 or uint16) or binary image.
    data:  Gray-scale (uint8 or uint16) or binary image. vector of
           points. Each row gives information regarding a
           geometrical primitive. The interpretation of this data is
           dependent on the parameter GEOM. The line drawing
           algorithm is not invariant to image transposition.
    value: Gray-scale (uint8 or uint16) or binary image. pixel
           gray-scale value associated to each point in parameter
           data. It can be a column vector of values or a single
           value.
    GEOM:  String Default: "". geometrical figure. One of
           'point','line', 'rect', or 'frect' for drawing points,
           lines, rectangles or filled rectangles respectively.
- Output
    y: Gray-scale (uint8 or uint16) or binary image. y has the same
       type of f .
- Description
    mmdrawv creates the image y by a superposition of points,
    rectangles and lines of gray-level k1 on the image f . The
    parameters for each geometrical primitive are defined by each
    line in the 'data' parameter. For points , they are represented
    by a matrix where each row gives the point's row and column, in
    this order. For lines , they are drawn with the same convention
    used by points, with a straight line connecting them in the
    order given by the data matrix. For rectangles and filled
    rectangles , each row in the data matrix gives the two points of
    the diagonal of the rectangle, where the points use the same
    row, column convention.
- Examples
    \#
    \#   example 1
    \#
    f=uint8(zeros((3,5)))
    pcoords=uint16([[0,2,4],
                    [0,0,2]])
    pvalue=uint16([1,2,3])
    print mmdrawv(f,pcoords,pvalue,'point')
    print mmdrawv(f,pcoords,pvalue,'line')
    rectcoords=uint16([[0],
                       [0],
                       [3],
                       [2]])
    print mmdrawv(f,rectcoords, uint16(5), 'rect')
    \#
    \#   example 2
    \#
    f=mmreadgray('blob3.tif')
    pc=mmblob(mmlabel(f),'centroid','data')
    lines=mmdrawv(mmintersec(f,0),transpose(pc),uint8(1),'line')
    mmshow(f,lines)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmdtshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmdtshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmdtshow}(\textit{f}, \textit{n}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Display a distance transform image with an iso-line color table.
- Synopsis
    y = mmdtshow(f, n=10)
- Input
    f: Gray-scale (uint8 or uint16) image. Distance transform.
    n: Boolean Default: 10. Number of iso-contours.
- Output
    y: Gray-scale (uint8 or uint16) or binary image. Optionally
       return RGB uint8 image
- Description
    Displays the distance transform image f (uint8 or uint16) with a
    special gray-scale color table with n pseudo-color equaly
    spaced. The final appearance of this display is similar to an
    iso-contour image display. The infinity value, which is the
    maximum level allowed in the image, is displayed as black. The
    image is displayed in the MATLAB figure only if no output
    parameter is given.
- Examples
    \#
    f=mmreadgray('blob.tif')
    fd=mmdist(f)
    mmshow(fd)
    mmdtshow(fd)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmedgeoff}
    \index{multireg.num\_pymorph \textit{(module)}!mmedgeoff \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmedgeoff}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Eliminate the objects that hit the image frame.
- Synopsis
    y = mmedgeoff(f, Bc=None)
- Input
    f:  Binary image.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity)
- Output
    y: Binary image.
- Description
    mmedgeoff creates the binary image y by eliminating the objects
    (connected components) of the binary image f that hit the image
    frame, according to the connectivity defined by the structuring
    element Bc .
- Examples
    \#
    a=mmreadgray('form-1.tif')
    b=mmedgeoff(a)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmendpoints}
    \index{multireg.num\_pymorph \textit{(module)}!mmendpoints \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmendpoints}(\textit{OPTION}=\texttt{'\-L\-O\-O\-P\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Interval to detect end-points.

      \item Synopsis Iab = mmendpoints(OPTION="LOOP")

      \item Input OPTION: String Default: "LOOP". 'LOOP' or 'HOMOTOPIC'

      \item Output Iab: Interval

      \item Description mmendpoints creates an interval that is useful to 
        detect end-points of curves (i.e., one pixel thick connected 
        components) in binary images. It can be used to prune skeletons 
        and to mark objects transforming them in a single pixel or closed 
        loops if they have holes. There are two options available: LOOP, 
        deletes all points but preserves loops if used in mmthin ; 
        HOMOTOPIC, deletes all points but preserves the last single point 
        or loops.

      \item Examples \# \# example 1 \# print mmintershow(mmendpoints()) \# 
        \# example 2 \# print mmintershow(mmendpoints('HOMOTOPIC')) \# \# 
        example 3 \# f = mmreadgray('pcbholes.tif') mmshow(f) f1 = 
        mmthin(f) mmshow(f1) f2 = mmthin(f1,mmendpoints(),20) mmshow(f2) 
        \# \# example 4 \# fn = mmthin(f1,mmendpoints('HOMOTOPIC')) 
        mmshow(mmdil(fn))

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmero}
    \index{multireg.num\_pymorph \textit{(module)}!mmero \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmero}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Erode an image by a structuring element.
- Synopsis
    y = mmero(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
- Output
    y: Image
- Description
    mmero performs the erosion of the image f by the structuring
    element b . Erosion is a neighbourhood operator that compairs
    locally b with f , according to an inclusion rule. Since erosion
    is a fundamental operator to the construction of all other
    morphological operators, it is also called an elementary
    operator of Mathematical Morphology. When f is a gray-scale
    image , b may be a flat or non-flat structuring element.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [1, 1, 1, 0, 0, 1, 1],
       [1, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 0, 0]])
    b=mmbinary([1, 1, 0])
    mmero(f,b)
    f=uint8([
       [ 0,   1,  2, 50,  4,  5],
       [ 2,   3,  4,  0,  0,  0],
       [12, 255, 14, 15, 16, 17]])
    mmero(f,b)
    \#
    \#   example 2
    \#
    f=mmbinary(mmreadgray('blob.tif'))
    bimg=mmbinary(mmreadgray('blob1.tif'))
    b=mmimg2se(bimg)
    g=mmero(f,b)
    mmshow(f)
    mmshow(g)
    mmshow(g,mmgradm(f))
    \#
    \#   example 3
    \#
    f=mmreadgray('pcb\_gray.tif')
    b=mmsedisk(3)
    mmshow(f)
    mmshow(mmero(f,b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmero_old}
    \index{multireg.num\_pymorph \textit{(module)}!mmero\_old \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmero\_old}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Erode an image by a structuring element.
- Synopsis
    y = mmero(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
- Output
    y: Image
- Description
    mmero performs the erosion of the image f by the structuring
    element b . Erosion is a neighbourhood operator that compairs
    locally b with f , according to an inclusion rule. Since erosion
    is a fundamental operator to the construction of all other
    morphological operators, it is also called an elementary
    operator of Mathematical Morphology. When f is a gray-scale
    image , b may be a flat or non-flat structuring element.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [1, 1, 1, 0, 0, 1, 1],
       [1, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 0, 0]])
    b=mmbinary([1, 1, 0])
    mmero(f,b)
    f=uint8([
       [ 0,   1,  2, 50,  4,  5],
       [ 2,   3,  4,  0,  0,  0],
       [12, 255, 14, 15, 16, 17]])
    mmero(f,b)
    \#
    \#   example 2
    \#
    f=mmbinary(mmreadgray('blob.tif'))
    bimg=mmbinary(mmreadgray('blob1.tif'))
    b=mmimg2se(bimg)
    g=mmero(f,b)
    mmshow(f)
    mmshow(g)
    mmshow(g,mmgradm(f))
    \#
    \#   example 3
    \#
    f=mmreadgray('pcb\_gray.tif')
    b=mmsedisk(3)
    mmshow(f)
    mmshow(mmero(f,b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmflood}
    \index{multireg.num\_pymorph \textit{(module)}!mmflood \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmflood}(\textit{fin}, \textit{T}, \textit{option}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Flooding filter- h,v,a-basin and dynamics (depth, area, volume)
- Synopsis
    y = mmflood(fin, T, option, Bc=None)
- Input
    fin:    Gray-scale (uint8 or uint16) image.
    T:      Criterion value. If T==-1, then the dynamics is
            determined, not the flooding at this criterion. This was
            selected just to use the same algoritm to compute two
            completely distinct functions.
    option: String Default: "". criterion: 'AREA', 'VOLUME', 'H'.
    Bc:     Structuring Element Default: None (3x3 elementary
            cross). Connectivity.
- Output
    y: Gray-scale (uint8 or uint16) image.
- Description
    This is a flooding algorithm. It is the basis to implement many
    topological functions. It is a connected filter that floods an
    image following some topological criteria: area, volume, depth.
    These filters are equivalent to area-close, volume-basin or
    h-basin, respectively. This code may be difficult to understand
    because of its many options. Basically, when t is negative, the
    generalized dynamics: area, volume, h is computed. When the
    flooding is computed, every time a new level in the flooding
    happens, a test is made to verify if the criterion has reached.
    This is used to set the value to that height. This value image
    will be used later for sup-reconstruction (flooding) at that
    particular level. This test happens in the raising of the water
    and in the merging of basins.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmframe}
    \index{multireg.num\_pymorph \textit{(module)}!mmframe \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmframe}(\textit{f}, \textit{WT}=\texttt{1\-}, \textit{HT}=\texttt{1\-}, \textit{DT}=\texttt{0\-}, \textit{k1}=\texttt{N\-o\-n\-e\-}, \textit{k2}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Create a frame image.
- Synopsis
    y = mmframe(f, WT=1, HT=1, DT=0, k1=None, k2=None)
- Input
    f:  Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image.
    WT: Double Default: 1. Positive integer ( width thickness).
    HT: Double Default: 1. Positive integer ( height thickness).
    DT: Double Default: 0. Positive integer ( depth thickness).
    k1: Non-negative integer. Default: None (Maximum pixel value
        allowed in f). Frame gray-level.
    k2: Non-negative integer. Default: None (Minimum pixel value
        allowed in f). Background gray level.
- Output
    y: image of same type as f .
- Description
    mmframe creates an image y , with the same dimensions (W,H,D)
    and same pixel type of the image f , such that the value of the
    pixels in the image frame is k1 and the value of the other
    pixels is k2 . The thickness of the image frame is DT.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmfreedom}
    \index{multireg.num\_pymorph \textit{(module)}!mmfreedom \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmfreedom}(\textit{L}=\texttt{5\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Control automatic data type conversion.
- Synopsis
    Y = mmfreedom(L=5)
- Input
    L: Double Default: 5. level of FREEDOM: 0, 1 or 2. If the input
       parameter is omitted, the current level is returned.
- Output
    Y: Double current FREEDOM level
- Description
    mmfreedom controls the automatic data type conversion. There are
    3 possible levels, called FREEDOM levels, for automatic
    conversion: 0 - image type conversion is not allowed; 1- image
    type conversion is allowed, but a warning is sent for each
    conversion; 2- image type conversion is allowed without warning.
    The FREEDOM levels are set or inquired by mmfreedom . If an
    image is not in the required datatype, than it should be
    converted to the maximum and nearest pymorph Morphology Toolbox
    datatype. For example, if an image is in int32 and a
    morphological gray-scale processing that accepts only binary,
    uint8 or uint16 images, is required, it will be converted to
    uint16. Another example, if a binary image should be added to a
    uint8 image, the binary image will be converted to uint8. In
    cases of operators that have as parameters an image and a
    constant, the type of the image should be kept as reference,
    while the type of the constant should be converted, if
    necessary.
- Examples
    \#
    \#   example 1
    \#
    a=mmsubm([4., 2., 1.],uint8([3, 2, 0]))
    print a
    print mmdatatype(a)
    \#
    \#   example 2
    \#
    a=mmsubm([4., 2., 1], mmbinary([3, 2, 0]))
    print a
    print mmdatatype(a)
    \#
    \#   example 3
    \#
    a=mmsubm(uint8([4, 3, 2, 1]), 1)
    print a
    print mmdatatype(a)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgdist}
    \index{multireg.num\_pymorph \textit{(module)}!mmgdist \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgdist}(\textit{f}, \textit{g}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{METRIC}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Geodesic Distance Transform.
- Synopsis
    y = mmgdist(f, g, Bc=None, METRIC=None)
- Input
    f:      Binary image.
    g:      Binary image. Marker image
    Bc:     Structuring Element Default: None (3x3 elementary
            cross). (metric for distance).
    METRIC: String Default: None. 'EUCLIDEAN' if specified.
- Output
    y: uint16 (distance image).
- Description
    mmgdist creates the geodesic distance image y of the binary
    image f relative to the binary image g . The value of y at the
    pixel x is the length of the smallest path between x and f . The
    distances available are based on the Euclidean metrics and on
    metrics generated by a neighbourhood graph, that is
    characterized by a connectivity rule defined by the structuring
    element Bc . The connectivity for defining the paths is
    consistent with the metrics adopted to measure their length. In
    the case of the Euclidean distance, the space is considered
    continuos and, in the other cases, the connectivity is the one
    defined by Bc .
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
     [1,1,1,1,1,1],
     [1,1,1,0,0,1],
     [1,0,1,0,0,1],
     [1,0,1,1,0,0],
     [0,0,1,1,1,1],
     [0,0,0,1,1,1]])
    g=mmbinary([
     [0,0,0,0,0,0],
     [1,1,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,1]])
    y=mmgdist(f,g,mmsecross())
    print y
    \#
    \#   example 2
    \#
    f=mmreadgray('maze\_bw.tif')
    g=mmintersec(f,0)
    g=mmdrawv(g,uint16([[2],[2],[6],[6]]),uint16(1),'frect')
    y=mmgdist(f,g,mmsebox(),'EUCLIDEAN')
    mmshow(f,g)
    mmdtshow(y,200)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgdtshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmgdtshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgdtshow}(\textit{X}, \textit{N}=\texttt{1\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Apply an iso-line color table to a gray-scale image.

      \item Synopsis Y = mmgdtshow(X, N=10)

      \item Input X: Gray-scale (uint8 or uint16) image. Distance transform 
        image. N: Default: 10. Number of iso-contours.

      \item Output Y: Gray-scale (uint8 or uint16) or binary image.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmglblshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmglblshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmglblshow}(\textit{X}, \textit{border}=\texttt{0\-.\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Apply a random color table to a gray-scale image.

      \item Synopsis Y = mmglblshow(X, border=0.0)

      \item Input X: Gray-scale (uint8 or uint16) image. Labeled image. 
        border: Boolean Default: 0.0. Labeled image.

      \item Output Y: Gray-scale (uint8 or uint16) or binary image.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgradm}
    \index{multireg.num\_pymorph \textit{(module)}!mmgradm \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgradm}(\textit{f}, \textit{Bdil}=\texttt{N\-o\-n\-e\-}, \textit{Bero}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Morphological gradient.
- Synopsis
    y = mmgradm(f, Bdil=None, Bero=None)
- Input
    f:    Gray-scale (uint8 or uint16) or binary image.
    Bdil: Structuring Element Default: None (3x3 elementary cross).
          for the dilation.
    Bero: Structuring Element Default: None (3x3 elementary cross).
          for the erosion.
- Output
    y: Gray-scale (uint8 or uint16) or binary image. (same type of f
       ).
- Description
    mmgradm creates the image y by the subtraction of the erosion of
    the image f by Bero of the dilation of f by Bdil .
- Examples
    \#
    \#   example 1
    \#
    a = mmreadgray('small\_bw.tif')
    b = mmgradm(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 2
    \#
    c=mmgradm(a,mmsecross(0),mmsecross())
    d=mmgradm(a,mmsecross(),mmsecross(0))
    mmshow(a,c)
    mmshow(a,d)
    \#
    \#   example 3
    \#
    a = mmreadgray('bloodcells.tif')
    b = mmgradm(a)
    mmshow(a)
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgrain}
    \index{multireg.num\_pymorph \textit{(module)}!mmgrain \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgrain}(\textit{fr}, \textit{f}, \textit{measurement}, \textit{option}=\texttt{'\-i\-m\-a\-g\-e\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Gray-scale statistics for each labeled region.
- Synopsis
    y = mmgrain(fr, f, measurement, option="image")
- Input
    fr:          Gray-scale (uint8 or uint16) image. Labeled image,
                 to define the regions. Label 0 is the background
                 region.
    f:           Gray-scale (uint8 or uint16) image. To extract the
                 measuremens.
    measurement: String Default: "". Choose the measure to compute:
                 'max', 'min', 'median', 'mean', 'sum', 'std',
                 'std1'.
    option:      String Default: "image". Output format: 'image':
                 results as a gray-scale mosaic image (uint16);
                 'data': results a column vector of measurements
                 (double).
- Output
    y: Gray-scale (uint8 or uint16) image. Or a column vector
       (double) with gray-scale statistics per region.
- Description
    Computes gray-scale statistics of each grain in the image. The
    grains regions are specified by the labeled image fr and the
    gray-scale information is specified by the image f . The
    statistics to compute is specified by the parameter measurement
    , which has the same options as in function mmstats . The
    parameter option defines: ('image') if the output is an uint16
    image where each label value is changed to the measurement
    value, or ('data') a double column vector. In this case, the
    first element (index 1) is the measurement of region 1. The
    region with label zero is not measure as it is normally the
    background.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([range(6),range(6),range(6)])
    fr=mmlabelflat(f)
    mmgrain(fr,f,'sum','data')
    mmgrain(fr,f,'sum')
    \#
    \#   example 2
    \#
    f=mmreadgray('astablet.tif')
    g=mmgradm(f)
    marker=mmregmin(mmclose(g))
    ws=mmcwatershed(g,marker,mmsebox(),'regions')
    g=mmgrain(ws,f,'mean')
    mmshow(f)
    mmshow(g)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgray}
    \index{multireg.num\_pymorph \textit{(module)}!mmgray \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgray}(\textit{f}, \textit{TYPE}=\texttt{'\-u\-i\-n\-t\-8\-'\-}, \textit{k1}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Convert a binary image into a gray-scale image.
- Synopsis
    y = mmgray(f, TYPE="uint8", k1=None)
- Input
    f:    Binary image.
    TYPE: String Default: "uint8". 'uint8', 'uint16', or 'int32'.
    k1:   Non-negative integer. Default: None (Maximum pixel level
          in pixel type).
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmgray converts a binary image into a gray-scale image of a
    specified data type. The value k1 is assigned to the 1 pixels of
    f , while the 0 pixels are assigned to the minimum value
    associated to the specified data type.
- Examples
    \#
    b=mmbinary([0, 1, 0, 1])
    print b
    c=mmgray(b)
    print c
    d=mmgray(b,'uint8',100)
    print d
    e=mmgray(b,'uint16')
    print e
    f=mmgray(b,'int32',0)
    print f\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmgshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmgshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmgshow}(\textit{X}, \textit{X1}=\texttt{N\-o\-n\-e\-}, \textit{X2}=\texttt{N\-o\-n\-e\-}, \textit{X3}=\texttt{N\-o\-n\-e\-}, \textit{X4}=\texttt{N\-o\-n\-e\-}, \textit{X5}=\texttt{N\-o\-n\-e\-}, \textit{X6}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Apply binary overlays as color layers on a binary or 
        gray-scale image

      \item Synopsis Y = mmgshow(X, X1=None, X2=None, X3=None, X4=None, 
        X5=None, X6=None)

      \item Input X: Gray-scale (uint8 or uint16) or binary image. X1: Binary 
        image. Default: None. Red overlay. X2: Binary image. Default: 
        None. Green overlay. X3: Binary image. Default: None. Blue 
        overlay. X4: Binary image. Default: None. Magenta overlay. X5: 
        Binary image. Default: None. Yellow overlay. X6: Binary image. 
        Default: None. Cyan overlay.

      \item Output Y: Gray-scale (uint8 or uint16) or binary image.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmhistogram}
    \index{multireg.num\_pymorph \textit{(module)}!mmhistogram \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmhistogram}(\textit{f}, \textit{option}=\texttt{'\-u\-i\-n\-t\-1\-6\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Find the histogram of the image f.
- Synopsis
    h = mmhistogram(f, option="uint16")
- Input
    f:      Gray-scale (uint8 or uint16) or binary image.
    option: String Default: "uint16". Values: "uint16" or "int32".
- Output
    h: Gray-scale (uint8 or uint16) image. Histogram in a uint16 or
       an int32 vector.
- Description
    Finds the histogram of the image f and returns the result in the
    vector h . For binary image the vector size is 2, for gray-scale
    uint8 and uint16 images, the vector size is the maximum pixel
    value plus one. h[0] gives the number of pixels with value 0.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([0, 1, 1, 2, 2, 2, 5, 3, 5])
    h=mmhistogram(f)
    print h
    \#
    \#   example 2
    \#
    f=mmreadgray('lenina.tif')
    mmshow(f)
    h=mmhistogram(f)
    mmplot([[h]],[['style', 'impulses']])\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmhmax}
    \index{multireg.num\_pymorph \textit{(module)}!mmhmax \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmhmax}(\textit{f}, \textit{h}=\texttt{1\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Remove peaks with contrast less than h.
- Synopsis
    y = mmhmax(f, h=1, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    h:  Default: 1. Contrast parameter.
    Bc: Structuring Element Default: None (3x3 elementary cross).
        Structuring element ( connectivity).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmhmax inf-reconstructs the gray-scale image f from the marker
    created by the subtraction of the positive integer value h from
    f , using connectivity Bc . This operator removes connected
    peaks with contrast less than h .
- Examples
    \#
    \#   example 1
    \#
    a = uint8([
        [4,   3,   6,  1,  3,  5,  2],
        [2,   9,   6,  1,  6,  7,  3],
        [8,   9,   3,  2,  4,  9,  4],
        [3,   1,   2,  1,  2,  4,  2]])
    print mmhmax(a,2,mmsebox())
    \#
    \#   example 2
    \#
    f = mmreadgray('r4x2\_256.tif')
    mmshow(f)
    fb = mmhmax(f,50)
    mmshow(fb)
    mmshow(mmregmax(fb))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmhmin}
    \index{multireg.num\_pymorph \textit{(module)}!mmhmin \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmhmin}(\textit{f}, \textit{h}=\texttt{1\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Remove basins with contrast less than h.
- Synopsis
    y = mmhmin(f, h=1, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    h:  Default: 1. Contrast parameter.
    Bc: Structuring Element Default: None (3x3 elementary cross).
        Structuring element (connectivity).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmhmin sup-reconstructs the gray-scale image f from the marker
    created by the addition of the positive integer value h to f ,
    using the connectivity Bc . This operator removes connected
    basins with contrast less than h . This function is very userful
    for simplifying the basins of the image.
- Examples
    \#
    \#   example 1
    \#
    a = uint8([
        [10,   3,   6,  18,  16,  15,  10],
        [10,   9,   6,  18,   6,   5,  10],
        [10,   9,   9,  15,   4,   9,  10],
        [10,  10,  10,  10,  10,  10,  10]])
    print mmhmin(a,1,mmsebox())
    \#
    \#   example 2
    \#
    f = mmreadgray('r4x2\_256.tif')
    mmshow(f)
    fb = mmhmin(f,70)
    mmshow(fb)
    mmshow(mmregmin(fb))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmhomothick}
    \index{multireg.num\_pymorph \textit{(module)}!mmhomothick \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmhomothick}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Interval for homotopic thickening.

      \item Synopsis Iab = mmhomothick()

      \item Output Iab: Interval

      \item Description mmhomothick creates an interval that is useful for 
        the homotopic (i.e., that conserves the relation between objects 
        and holes) thickening of binary images.

      \item Examples \# print mmintershow(mmhomothick())

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmhomothin}
    \index{multireg.num\_pymorph \textit{(module)}!mmhomothin \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmhomothin}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Interval for homotopic thinning.

      \item Synopsis Iab = mmhomothin()

      \item Output Iab: Interval

      \item Description mmhomothin creates an interval that is useful for the 
        homotopic (i.e., that conserves the relation between objects and 
        holes) thinning of binary images.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmimg2se}
    \index{multireg.num\_pymorph \textit{(module)}!mmimg2se \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmimg2se}(\textit{fd}, \textit{FLAT}=\texttt{'\-F\-L\-A\-T\-'\-}, \textit{f}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Create a structuring element from a pair of images.
- Synopsis
    B = mmimg2se(fd, FLAT="FLAT", f=None)
- Input
    fd:   Binary image. The image is in the matrix format where the
          origin (0,0) is at the matrix center.
    FLAT: String Default: "FLAT". 'FLAT' or 'NON-FLAT'.
    f:    Unsigned gray-scale (uint8 or uint16), signed (int32) or
          binary image. Default: None.
- Output
    B: Structuring Element
- Description
    mmimg2se creates a flat structuring element B from the binary
    image fd or creates a non-flat structuring element b from the
    binary image fd and the gray-scale image f . fd represents the
    domain of b and f represents the image of the points in fd .
- Examples
    \#
    \#   example 1
    \#
    a = mmimg2se(mmbinary([
      [0,1,0],
      [1,1,1],
      [0,1,0]]))
    print mmseshow(a)
    \#
    \#   example 2
    \#
    b = mmbinary([
      [0,1,1,1],
      [1,1,1,0]])
    b1 = mmimg2se(b)
    print mmseshow(b1)
    \#
    \#   example 3
    \#
    c = mmbinary([
      [0,1,0],
      [1,1,1],
      [0,1,0]])
    d = int32([
      [0,0,0],
      [0,1,0],
      [0,0,0]])
    e = mmimg2se(c,'NON-FLAT',d)
    print mmseshow(e)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminfcanon}
    \index{multireg.num\_pymorph \textit{(module)}!mminfcanon \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminfcanon}(\textit{f}, \textit{Iab}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Intersection of inf-generating operators.
- Synopsis
    y = mminfcanon(f, Iab, theta=45, DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    Iab:       Interval
    theta:     Double Default: 45. Degrees of rotation: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'
- Output
    y: Binary image.
- Description
    mminfcanon creates the image y by computing intersections of
    transformations of the image f by inf-generating (i.e., dual of
    the hit-or-miss) operators. These inf-generating operators are
    characterized by rotations (in the clockwise or anti-clockwise
    direction) of theta degrees of the interval Iab .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminfgen}
    \index{multireg.num\_pymorph \textit{(module)}!mminfgen \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminfgen}(\textit{f}, \textit{Iab})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Inf-generating.

      \item Synopsis y = mminfgen(f, Iab)

      \item Input f: Binary image. Iab: Interval

      \item Output y: Binary image.

      \item Description mminfgen creates the image y by computing the 
        transformation of the image f by the inf-generating operator (or 
        dual of the hit-or-miss) characterized by the interval Iab .

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminfrec}
    \index{multireg.num\_pymorph \textit{(module)}!mminfrec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminfrec}(\textit{f}, \textit{g}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Inf-reconstruction.
- Synopsis
    y = mminfrec(f, g, bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image. Marker image.
    g:  Gray-scale (uint8 or uint16) or binary image. Conditioning
        image.
    bc: Structuring Element Default: None (3x3 elementary cross).
        Structuring element ( connectivity).
- Output
    y: Image
- Description
    mminfrec creates the image y by an infinite number of recursive
    iterations (iterations until stability) of the dilation of f by
    bc conditioned to g . We say the y is the inf-reconstruction of
    g from the marker f . For algorithms and applications, see
    Vinc:93b .
- Examples
    \#
    \#   example 1
    \#
    g=mmreadgray('text\_128.tif')
    f=mmero(g,mmseline(9,90))
    y=mminfrec(f,g,mmsebox())
    mmshow(g)
    mmshow(f)
    mmshow(y)
    \#
    \#   example 2
    \#
    g=mmneg(mmreadgray('n2538.tif'))
    f=mmintersec(g,0)
    f=mmdraw(f,'LINE:40,30,60,30:END')
    y30=mmcdil(f,g,mmsebox(),30)
    y=mminfrec(f,g,mmsebox())
    mmshow(g)
    mmshow(f)
    mmshow(y30)
    mmshow(y)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminpos}
    \index{multireg.num\_pymorph \textit{(module)}!mminpos \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminpos}(\textit{f}, \textit{g}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Minima imposition.
- Synopsis
    y = mminpos(f, g, bc=None)
- Input
    f:  Binary image. Marker image.
    g:  Gray-scale (uint8 or uint16) image. input image.
    bc: Structuring Element Default: None (3x3 elementary cross).
        (connectivity).
- Output
    y: Gray-scale (uint8 or uint16) image.
- Description
    Minima imposition on g based on the marker f . mminpos creates
    an image y by filing the valleys of g that does not cover the
    connect components of f . A remarkable property of y is that its
    regional minima are exactly the connect components of g .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminstall}
    \index{multireg.num\_pymorph \textit{(module)}!mminstall \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminstall}(\textit{code}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Verify if the Morphology Toolbox is registered.

      \item Synopsis mminstall(code=None)

      \item Input code: String Default: None. Authorization code.

      \item Description mminstall verifies if the toolbox is registered or 
        not. If not, it identifies the internal code that must be used to 
        get the authorization code from the software manufacturer.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mminterot}
    \index{multireg.num\_pymorph \textit{(module)}!mminterot \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mminterot}(\textit{Iab}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Rotate an interval
- Synopsis
    Irot = mminterot(Iab, theta=45, DIRECTION="CLOCKWISE")
- Input
    Iab:       Interval
    theta:     Double Default: 45. Degrees of rotation. Available
               values are multiple of 45 degrees.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'.
- Output
    Irot: Interval
- Description
    mminterot rotates the interval Iab by an angle theta .
- Examples
    \#
    b1 = mmendpoints()
    b2 = mminterot(b1)
    print mmintershow(b1)
    print mmintershow(b2)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmintersec}
    \index{multireg.num\_pymorph \textit{(module)}!mmintersec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmintersec}(\textit{f1}, \textit{f2}, \textit{f3}=\texttt{N\-o\-n\-e\-}, \textit{f4}=\texttt{N\-o\-n\-e\-}, \textit{f5}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Intersection of images.
- Synopsis
    y = mmintersec(f1, f2, f3=None, f4=None, f5=None)
- Input
    f1: Gray-scale (uint8 or uint16) or binary image.
    f2: Gray-scale (uint8 or uint16) or binary image. Or constant.
    f3: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
    f4: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
    f5: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
- Output
    y: Image
- Description
    mmintersec creates the image y by taking the pixelwise minimum
    between the images f1, f2, f3, f4, and f5 . When f1, f2, f3, f4,
    and f5 are binary images, y is the intersection of them.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([255,  255,    0,   10,    0,   255,   250])
    g=uint8([ 0,    40,   80,   140,  250,    10,    30])
    print mmintersec(f, g)
    print mmintersec(f, 0)
    \#
    \#   example 2
    \#
    a = mmreadgray('form-ok.tif')
    b = mmreadgray('form-1.tif')
    c = mmintersec(a,b)
    mmshow(a)
    mmshow(b)
    mmshow(c)
    \#
    \#   example 3
    \#
    d = mmreadgray('tplayer1.tif')
    e = mmreadgray('tplayer2.tif')
    f = mmreadgray('tplayer3.tif')
    g = mmintersec(d,e,f)
    mmshow(d)
    mmshow(e)
    mmshow(f)
    mmshow(g)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmintershow}
    \index{multireg.num\_pymorph \textit{(module)}!mmintershow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmintershow}(\textit{Iab})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Visualize an interval.

      \item Synopsis s = mmintershow(Iab)

      \item Input Iab: Interval

      \item Output s: String ( representation of the interval).

      \item Description mmintershow creates a representation for an interval 
        using 0, 1 and . ( don't care).

      \item Examples \# print mmintershow(mmhomothin())

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmis}
    \index{multireg.num\_pymorph \textit{(module)}!mmis \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmis}(\textit{f1}, \textit{oper}, \textit{f2}=\texttt{N\-o\-n\-e\-}, \textit{oper1}=\texttt{N\-o\-n\-e\-}, \textit{f3}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Verify if a relationship among images is true or false.
- Synopsis
    y = mmis(f1, oper, f2=None, oper1=None, f3=None)
- Input
    f1:    Gray-scale (uint8 or uint16) or binary image.
    oper:  String relationship from: '==', '{\textasciitilde}=', '{\textless}','{\textless}=', '{\textgreater}',
           '{\textgreater}=', 'binary', 'gray'.
    f2:    Gray-scale (uint8 or uint16) or binary image. Default:
           None.
    oper1: String Default: None. relationship from: '==', '{\textasciitilde}=',
           '{\textless}','{\textless}=', '{\textgreater}', '{\textgreater}='.
    f3:    Gray-scale (uint8 or uint16) or binary image. Default:
           None.
- Output
    y: Bool value: 0 or 1
- Description
    Verify if the property or relatioship between images is true or
    false. The result is true if the relationship is true for all
    the pixels in the image, and false otherwise. (Obs: This
    function replaces mmis equal, mmis lesseq, mmis binary ).
- Examples
    \#
    fbin=mmbinary([0, 1])
    f1=uint8([1, 2, 3])
    f2=uint8([2, 2, 3])
    f3=uint8([2, 3, 4])
    mmis(fbin,'binary')
    mmis(f1,'gray')
    mmis(f1,'==',f2)
    mmis(f1,'{\textless}',f3)
    mmis(f1,'{\textless}=',f2)
    mmis(f1,'{\textless}=',f2,'{\textless}=',f3)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmisbinary}
    \index{multireg.num\_pymorph \textit{(module)}!mmisbinary \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmisbinary}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Check for binary image

      \item Synopsis bool = mmisbinary(f)

      \item Input f:

      \item Output bool: Boolean

      \item Description mmisbinary returns TRUE(1) if the datatype of the 
        input image is binary. A binary image has just the values 0 and 
        1.

      \item Examples \# a=uint8([0, 1, 0, 1]) print mmisbinary(a) b=(a) print 
        mmisbinary(b)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmisequal}
    \index{multireg.num\_pymorph \textit{(module)}!mmisequal \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmisequal}(\textit{f1}, \textit{f2}, \textit{MSG}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Verify if two images are equal
- Synopsis
    bool = mmisequal(f1, f2)
- Input
    f1:  Unsigned gray-scale (uint8 or uint16), signed (int32) or
         binary image.
    f2:  Unsigned gray-scale (uint8 or uint16), signed (int32) or
         binary image.
- Output
    bool: Boolean
- Description
    mmisequal compares the images f1 and f2 and returns true (1), if
    f1(x)=f2(x) , for all pixel x , and false (0), otherwise.
- Examples
    \#
    f1 = uint8(arrayrange(4))
    print f1
    f2 = uint8([9, 5, 3, 3])
    print f2
    f3 = f1
    mmisequal(f1,f2)
    mmisequal(f1,f3)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmislesseq}
    \index{multireg.num\_pymorph \textit{(module)}!mmislesseq \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmislesseq}(\textit{f1}, \textit{f2}, \textit{MSG}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Verify if one image is less or equal another (is beneath)

      \item Synopsis bool = mmislesseq(f1, f2)

      \item Input f1: Gray-scale (uint8 or uint16) or binary image. f2: 
        Gray-scale (uint8 or uint16) or binary image.

      \item Output bool: Boolean

      \item Description mmislesseq compares the images f1 and f2 and returns 
        true (1), if f1(x) {\textless}= f2(x) , for every pixel x, and 
        false (0), otherwise.

      \item Examples \# f1 = uint8([0, 1, 2, 3]) f2 = uint8([9, 5, 3, 3]) 
        print mmislesseq(f1,f2) print mmislesseq(f2,f1) print 
        mmislesseq(f1,f1)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmlabel}
    \index{multireg.num\_pymorph \textit{(module)}!mmlabel \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmlabel}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Label a binary image.
- Synopsis
    y = mmlabel(f, Bc=None)
- Input
    f:  Binary image.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: Image If number of labels is less than 65535, the data type
       is uint16, otherwise it is int32.
- Description
    mmlabel creates the image y by labeling the connect components
    of a binary image f , according to the connectivity defined by
    the structuring element Bc . The background pixels (with value
    0) are not labeled. The maximum label value in the output image
    gives the number of its connected components.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [0,1,0,1,1],
       [1,0,0,1,0]])
    g=mmlabel(f)
    print g
    \#
    \#   example 2
    \#
    f = mmreadgray('blob3.tif')
    g=mmlabel(f)
    nblobs=mmstats(g,'max')
    print nblobs
    mmshow(f)
    mmlblshow(g)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmlabelflat}
    \index{multireg.num\_pymorph \textit{(module)}!mmlabelflat \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmlabelflat}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{\_lambda}=\texttt{0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Label the flat zones of gray-scale images.
- Synopsis
    y = mmlabelflat(f, Bc=None, \_lambda=0)
- Input
    f:       Gray-scale (uint8 or uint16) or binary image.
    Bc:      Structuring Element Default: None (3x3 elementary
             cross). ( connectivity).
    \_lambda: Default: 0. Connectivity given by {\textbar}f(q)-f(p){\textbar}{\textless}=\_lambda.
- Output
    y: Image If number of labels is less than 65535, the data type
       is uint16, otherwise it is int32.
- Description
    mmlabelflat creates the image y by labeling the flat zones of f
    , according to the connectivity defined by the structuring
    element Bc . A flat zone is a connected region of the image
    domain in which all the pixels have the same gray-level
    (lambda=0 ). When lambda is different than zero, a quasi-flat
    zone is detected where two neighboring pixels belong to the same
    region if their difference gray-levels is smaller or equal
    lambda . The minimum label of the output image is 1 and the
    maximum is the number of flat-zones in the image.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([
       [5,5,8,3,0],
       [5,8,8,0,2]])
    g=mmlabelflat(f)
    print g
    g1=mmlabelflat(f,mmsecross(),2)
    print g1
    \#
    \#   example 2
    \#
    f=mmreadgray('blob.tif')
    d=mmdist(f,mmsebox(),'euclidean')
    g= d /8
    mmshow(g)
    fz=mmlabelflat(g,mmsebox());
    mmlblshow(fz)
    print mmstats(fz,'max')
    \#
    \#   example 3
    \#
    f=mmreadgray('pcb\_gray.tif')
    g=mmlabelflat(f,mmsebox(),3)
    mmshow(f)
    mmlblshow(g)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmlastero}
    \index{multireg.num\_pymorph \textit{(module)}!mmlastero \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmlastero}(\textit{f}, \textit{B}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Last erosion.

      \item Synopsis y = mmlastero(f, B=None)

      \item Input f: Binary image. B: Structuring Element Default: None (3x3 
        elementary cross).

      \item Output y: Binary image.

      \item Description mmlastero creates the image y by computing the last 
        erosion by the structuring element B of the image f . The objects 
        found in y are the objects of the erosion by nB that can not be 
        reconstructed from the erosion by (n+1)B , where n is a generic 
        non negative integer. The image y is a proper subset of the 
        morphological skeleton by B of f .

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmlblshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmlblshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmlblshow}(\textit{f}, \textit{option}=\texttt{'\-n\-o\-b\-o\-r\-d\-e\-r\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Display a labeled image assigning a random color for each label.
- Synopsis
    y = mmlblshow(f, option='noborder')
- Input
    f:      Gray-scale (uint8 or uint16) image. Labeled image.
    option: String Default: 'noborder'. BORDER or NOBORDER: includes
            or not a white border around each labeled region
- Output
    y: Gray-scale (uint8 or uint16) or binary image. Optionally
       return RGB uint8 image
- Description
    Displays the labeled image f (uint8 or uint16) with a pseudo
    color where each label appears with a random color. The image is
    displayed in the MATLAB figure only if no output parameter is
    given.
- Examples
    \#
    f=mmreadgray('blob3.tif')
    f1=mmlabel(f,mmsebox())
    mmshow(f1)
    mmlblshow(f1)
    mmlblshow(f1,'border')\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmlimits}
    \index{multireg.num\_pymorph \textit{(module)}!mmlimits \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmlimits}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Get the possible minimum and maximum of an image.
- Synopsis
    y = mmlimits(f)
- Input
    f: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Output
    y: Vector, the first element is the infimum, the second, the
       supremum.
- Description
    The possible minimum and the possible maximum of an image depend
    on its data type. These values are important to compute many
    morphological operators (for instance, negate of an image). The
    output is a vector, where the first element is the possible
    minimum and the second, the possible maximum.
- Examples
    \#
    print mmlimits(mmbinary([0, 1, 0]))
    print mmlimits(uint8([0, 1, 2]))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmmat2set}
    \index{multireg.num\_pymorph \textit{(module)}!mmmat2set \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmmat2set}(\textit{A})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Converts image representation from matrix to set
- Synopsis
    CV = mmmat2set(A)
- Input
    A: Image in matrix format, where the origin (0,0) is at the
       center of the matrix.
- Output
    CV: Image Tuple with array of pixel coordinates and array of
        corresponding pixel values
- Description
    Return tuple with array of pixel coordinates and array of
    corresponding pixel values. The input image is in the matrix
    format, like the structuring element, where the origin (0,0) is
    at the center of the matrix.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([[1,2,3],[4,5,6],[7,8,9]])
    i,v=mmmat2set(f)
    print i
    print v
    \#
    \#   example 2
    \#
    f=uint8([[1,2,3,4],[5,6,7,8]])
    i,v=mmmat2set(f)
    print i
    print v\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmmaxleveltype}
    \index{multireg.num\_pymorph \textit{(module)}!mmmaxleveltype \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmmaxleveltype}(\textit{TYPE}=\texttt{'\-u\-i\-n\-t\-8\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Returns the maximum value associated to an image datatype
- Synopsis
    max = mmmaxleveltype(TYPE='uint8')
- Input
    TYPE: String Default: 'uint8'. One of the strings 'uint8',
          'uint16' or 'int32', specifying the image type
- Output
    max: the maximum level value of type TYPE\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmneg}
    \index{multireg.num\_pymorph \textit{(module)}!mmneg \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmneg}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Negate an image.
- Synopsis
    y = mmneg(f)
- Input
    f: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmneg returns an image y that is the negation (i.e., inverse or
    involution) of the image f . In the binary case, y is the
    complement of f .
- Examples
    \#
    \#   example 1
    \#
    f=uint8([255, 255, 0, 10, 20, 10, 0, 255, 255])
    print mmneg(f)
    print mmneg(uint8([0, 1]))
    print mmneg(int32([0, 1]))
    \#
    \#   example 2
    \#
    a = mmreadgray('gear.tif')
    b = mmneg(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 3
    \#
    c = mmreadgray('astablet.tif')
    d = mmneg(c)
    mmshow(c)
    mmshow(d)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmopen}
    \index{multireg.num\_pymorph \textit{(module)}!mmopen \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmopen}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Morphological opening.

      \item Synopsis y = mmopen(f, b=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. b: 
        Structuring Element Default: None (3x3 elementary cross).

      \item Output y: Image

      \item Description mmopen creates the image y by the morphological 
        opening of the image f by the structuring element b . In the 
        binary case, the opening by the structuring element B may be 
        interpreted as the union of translations of B included in f . In 
        the gray-scale case, there is a similar interpretation taking the 
        functions umbra.

      \item Examples \# \# example 1 \# f=mmbinary(mmreadgray('blob.tif')) 
        bimg=mmbinary(mmreadgray('blob1.tif')) b=mmimg2se(bimg) mmshow(f) 
        mmshow(mmopen(f,b)) mmshow(mmopen(f,b),mmgradm(f)) \# \# example 
        2 \# a=mmbinary(mmreadgray('pcb1bin.tif')) b=mmopen(a,mmsebox(2)) 
        c=mmopen(a,mmsebox(4)) mmshow(a) mmshow(b) mmshow(c) \# \# 
        example 3 \# a=mmreadgray('astablet.tif') 
        b=mmopen(a,mmsedisk(18)) mmshow(a) mmshow(b)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmopenrec}
    \index{multireg.num\_pymorph \textit{(module)}!mmopenrec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmopenrec}(\textit{f}, \textit{bero}=\texttt{N\-o\-n\-e\-}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Opening by reconstruction.
- Synopsis
    y = mmopenrec(f, bero=None, bc=None)
- Input
    f:    Gray-scale (uint8 or uint16) or binary image.
    bero: Structuring Element Default: None (3x3 elementary cross).
          (erosion).
    bc:   Structuring Element Default: None (3x3 elementary cross).
          (connectivity).
- Output
    y: Image (same type of f ).
- Description
    mmopenrec creates the image y by an inf-reconstruction of the
    image f from its erosion by bero , using the connectivity
    defined by Bc .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmopenrecth}
    \index{multireg.num\_pymorph \textit{(module)}!mmopenrecth \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmopenrecth}(\textit{f}, \textit{bero}=\texttt{N\-o\-n\-e\-}, \textit{bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Open-by-Reconstruction Top-Hat.
- Synopsis
    y = mmopenrecth(f, bero=None, bc=None)
- Input
    f:    Gray-scale (uint8 or uint16) or binary image.
    bero: Structuring Element Default: None (3x3 elementary cross).
          (erosion)
    bc:   Structuring Element Default: None (3x3 elementary cross).
          ( connectivity)
- Output
    y: Gray-scale (uint8 or uint16) or binary image. (same type of f
       ).
- Description
    mmopenrecth creates the image y by subtracting the open by
    reconstruction of f , defined by the structuring elements bero e
    bc , of f itself.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmopenth}
    \index{multireg.num\_pymorph \textit{(module)}!mmopenth \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmopenth}(\textit{f}, \textit{b}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Opening Top Hat.
- Synopsis
    y = mmopenth(f, b=None)
- Input
    f: Gray-scale (uint8 or uint16) or binary image.
    b: Structuring Element Default: None (3x3 elementary cross).
       structuring element
- Output
    y: Gray-scale (uint8 or uint16) or binary image. (same type of f
       ).
- Description
    mmopenth creates the image y by subtracting the morphological
    opening of f by the structuring element b of f itself.
- Examples
    \#
    a = mmreadgray('keyb.tif')
    mmshow(a)
    b = mmopenth(a,mmsebox(3))
    mmshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmopentransf}
    \index{multireg.num\_pymorph \textit{(module)}!mmopentransf \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmopentransf}(\textit{f}, \textit{type}=\texttt{'\-O\-C\-T\-A\-G\-O\-N\-'\-}, \textit{n}=\texttt{6\-5\-5\-3\-5\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{Buser}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Open transform.
- Synopsis
    y = mmopentransf(f, type='OCTAGON', n=65535, Bc=None,
    Buser=None)
- Input
    f:     Binary image.
    type:  String Default: 'OCTAGON'. Disk family: 'OCTAGON',
           'CHESSBOARD', 'CITY-BLOCK', 'LINEAR-V', 'LINEAR-H',
           'LINEAR-45R', 'LINEAR-45L', 'USER'.
    n:     Default: 65535. Maximum disk radii.
    Bc:    Structuring Element Default: None (3x3 elementary cross).
           Connectivity for the reconstructive opening. Used if
           '-REC' suffix is appended in the 'type' string.
    Buser: Structuring Element Default: None (3x3 elementary cross).
           User disk, used if 'type' is 'USER'.
- Output
    y: Gray-scale (uint8 or uint16) image.
- Description
    Compute the open transform of a binary image. The value of the
    pixels in the open transform gives the largest radii of the disk
    plus 1, where the open by it is not empty at that pixel. The
    disk sequence must satisfy the following: if r {\textgreater} s, rB is
    sB-open, i.e. rB open by sB is equal rB. Note that the Euclidean
    disk does not satisfy this property in the discrete grid. This
    function also computes the reconstructive open transform by
    adding the suffix '-REC' in the 'type' parameter.
- Examples
    \#
    \#   example 1
    \#
    f = mmbinary([
                  [0,0,0,0,0,0,0,0],
                  [0,0,1,1,1,1,0,0],
                  [0,0,1,1,1,1,1,0],
                  [0,1,0,1,1,1,0,0],
                  [1,1,0,0,0,0,0,0]])
    print mmopentransf( f, 'city-block')
    print mmopentransf( f, 'linear-h')
    print mmopentransf( f, 'linear-45r')
    print mmopentransf( f, 'user',10,mmsecross(),mmbinary([0,1,1]))
    print mmopentransf( f, 'city-block-rec')
    \#
    \#   example 2
    \#
    f=mmreadgray('numbers.tif')
    mmshow(f)
    g=mmopentransf(f,'OCTAGON')
    mmshow(g)
    \#
    \#   example 3
    \#
    b=mmsedisk(3,'2D','OCTAGON')
    g1=mmopen(f,b)
    mmshow(g1)
    g2=mmcmp(g,'{\textgreater}',3)
    print mmis(g1,'==',g2)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmpad4n}
    \index{multireg.num\_pymorph \textit{(module)}!mmpad4n \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmpad4n}(\textit{f}, \textit{Bc}, \textit{value}, \textit{scale}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose mmpad4n

      \item Synopsis y = mmpad4n(f, Bc, value, scale=1)

      \item Input f: Image Bc: Structuring Element ( connectivity). value: 
        scale: Default: 1.

      \item Output y: The converted image

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmpatspec}
    \index{multireg.num\_pymorph \textit{(module)}!mmpatspec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmpatspec}(\textit{f}, \textit{type}=\texttt{'\-O\-C\-T\-A\-G\-O\-N\-'\-}, \textit{n}=\texttt{6\-5\-5\-3\-5\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{Buser}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Pattern spectrum (also known as granulometric size density).
- Synopsis
    h = mmpatspec(f, type='OCTAGON', n=65535, Bc=None, Buser=None)
- Input
    f:     Binary image.
    type:  String Default: 'OCTAGON'. Disk family: 'OCTAGON',
           'CHESSBOARD', 'CITY-BLOCK', 'LINEAR-V', 'LINEAR-H',
           'LINEAR-45R', 'LINEAR-45L', 'USER'.
    n:     Default: 65535. Maximum disk radii.
    Bc:    Structuring Element Default: None (3x3 elementary cross).
           Connectivity for the reconstructive granulometry. Used if
           '-REC' suffix is appended in the 'type' string.
    Buser: Structuring Element Default: None (3x3 elementary cross).
           User disk, used if 'type' is 'USER'.
- Output
    h: Gray-scale (uint8 or uint16) or binary image. a uint16
       vector.
- Description
    Compute the Pattern Spectrum of a binary image. See Mara:89b .
    The pattern spectrum is the histogram of the open transform, not
    taking the zero values.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmplot}
    \index{multireg.num\_pymorph \textit{(module)}!mmplot \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmplot}(\textit{plotitems}=\texttt{[\-]\-}, \textit{options}=\texttt{[\-]\-}, \textit{outfig}=\texttt{-\-1\-}, \textit{filename}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Plot a function.
- Synopsis
    fig = mmplot(plotitems=[], options=[], outfig=-1, filename=None)
- Input
    plotitems: Default: []. List of plotitems.
    options:   Default: []. List of options.
    outfig:    Default: -1. Integer. Figure number. 0 creates a new
               figure.
    filename:  Default: None. String. Name of the PNG output file.
- Output
    fig: Figure number.

- Examples
    \#
    import Numeric
    \#
    x = Numeric.arange(0, 2*Numeric.pi, 0.1)
    mmplot([[x]])
    y1 = Numeric.sin(x)
    y2 = Numeric.cos(x)
    opts = [['title', 'Example Plot'],                    ['grid'],                    ['style', 'linespoints'],                    ['xlabel', '"X values"'],                    ['ylabel', '"Y Values"']]
    y1\_plt = [x, y1, None,    'sin(X)']
    y2\_plt = [x, y2, 'lines', 'cos(X)']
    \#
    \# plotting two graphs using one step
    fig1 = mmplot([y1\_plt, y2\_plt], opts, 0)
    \#
    \# plotting the same graphs using two steps
    fig2 = mmplot([y1\_plt], opts, 0)
    fig2 = mmplot([y2\_plt], opts, fig2)
    \#
    \# first function has been lost, lets recover it
    opts.append(['replot'])
    fig2 = mmplot([y1\_plt], opts, fig2)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmreadgray}
    \index{multireg.num\_pymorph \textit{(module)}!mmreadgray \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmreadgray}(\textit{filename})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Read an image from a commercial file format and stores it 
        as a gray-scale image.

      \item Synopsis y = mmreadgray(filename)

      \item Input filename: String Name of file to read.

      \item Output y: Gray-scale (uint8 or uint16) or binary image.

      \item Description mmreadgray reads the image in filename and stores it 
        in y , an uint8 gray-scale image (without colormap). If the input 
        file is a color RGB image, it is converted to gray-scale using 
        the equation: y = 0.2989 R + 0.587 G + 0.114 B. This functions 
        uses de PIL module.

      \item Examples \# a=mmreadgray('cookies.tif') mmshow(a)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmregister}
    \index{multireg.num\_pymorph \textit{(module)}!mmregister \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmregister}(\textit{code}=\texttt{N\-o\-n\-e\-}, \textit{file\_name}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Register the SDC Morphology Toolbox.
- Synopsis
    s = mmregister(code=None, file\_name=None)
- Input
    code:      String Default: None. Authorization code.
    file\_name: String Default: None. Filename of the license file to
               be created.
- Output
    s: String Message of the status of the license.
- Description
    mmregister licenses the copy of the SDC Morphology Toolbox by
    entering the license code and the toolbox license file. If
    mmregister is called without parameters, it returns the internal
    code that must be sent for registration.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmregmax}
    \index{multireg.num\_pymorph \textit{(module)}!mmregmax \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmregmax}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Regional Maximum.
- Synopsis
    y = mmregmax(f, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    Bc: Structuring Element Default: None (3x3 elementary cross).
        (connectivity).
- Output
    y: Binary image.
- Description
    mmregmax creates a binary image y by computing the regional
    maxima of f , according to the connectivity defined by the
    structuring element Bc . A regional maximum is a flat zone not
    surrounded by flat zones of higher gray values.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmregmin}
    \index{multireg.num\_pymorph \textit{(module)}!mmregmin \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmregmin}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{option}=\texttt{'\-b\-i\-n\-a\-r\-y\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Regional Minimum (with generalized dynamics).
- Synopsis
    y = mmregmin(f, Bc=None, option="binary")
- Input
    f:      Gray-scale (uint8 or uint16) image.
    Bc:     Structuring Element Default: None (3x3 elementary
            cross). (connectivity).
    option: String Default: "binary". Choose one of: BINARY: output
            a binary image; VALUE: output a grayscale image with
            points at the regional minimum with the pixel values of
            the input image; DYNAMICS: output a grayscale image with
            points at the regional minimum with its dynamics;
            AREA-DYN: int32 image with the area-dynamics;
            VOLUME-DYN: int32 image with the volume-dynamics.
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmregmin creates a binary image f by computing the regional
    minima of f , according to the connectivity defined by the
    structuring element Bc . A regional minimum is a flat zone not
    surrounded by flat zones of lower gray values. A flat zone is a
    maximal connected component of a gray-scale image with same
    pixel values. There are three output options: binary image;
    valued image; and generalized dynamics. The dynamics of a
    regional minima is the minimum height a pixel has to climb in a
    walk to reach another regional minima with a higher dynamics.
    The area-dyn is the minimum area a catchment basin has to raise
    to reach another regional minima with higher area-dynamics. The
    volume-dyn is the minimum volume a catchment basin has to raise
    to reach another regional minima with a higher volume dynamics.
    The dynamics concept was first introduced in Grimaud:92 and it
    is the basic notion for the hierarchical or multiscale watershed
    transform.
- Examples
    \#
    \#   example 1
    \#
    a = uint8([
        [10,  10,  10,  10,  10,  10,  10],
        [10,   9,   6,  18,   6,   5,  10],
        [10,   9,   6,  18,   6,   5,  10],
        [10,   9,   9,  15,   4,   9,  10],
        [10,   9,   9,  15,  12,  10,  10],
        [10,  10,  10,  10,  10,  10,  10]])
    print mmregmin(a)
    print mmregmin(a,mmsecross(),'value')
    print mmregmin(a,mmsecross(),'dynamics')
    \#
    \#   example 2
    \#
    f1=mmreadgray('bloodcells.tif')
    m1=mmregmin(f1,mmsebox())
    mmshow(f1,m1)
    f2=mmhmin(f1,70)
    mmshow(f2)
    m2=mmregmin(f2,mmsebox())
    mmshow(f2,m2)
    \#
    \#   example 3
    \#
    f=mmreadgray('cameraman.tif')
    g=mmgradm(f)
    mh=mmregmin(g,mmsecross(),'dynamics')
    ws1=mmcwatershed(g, mmbinary(mh, 20))
    ws2=mmcwatershed(g, mmbinary(mh, 40))
    mmshow(ws1)
    mmshow(ws2)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmse2hmt}
    \index{multireg.num\_pymorph \textit{(module)}!mmse2hmt \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmse2hmt}(\textit{A}, \textit{Bc})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Create a Hit-or-Miss Template (or interval) from a pair 
        of structuring elements.

      \item Synopsis Iab = mmse2hmt(A, Bc)

      \item Input A: Structuring Element Left extremity. Bc: Structuring 
        Element Complement of the right extremity.

      \item Output Iab: Interval

      \item Description mmse2hmt creates the Hit-or-Miss Template (HMT), also 
        called interval [A,Bc] from the structuring elements A and Bc 
        such that A is included in the complement of Bc . The only 
        difference between this function and mmse2interval is that here 
        the second structuring element is the complement of the one used 
        in the other function. The advantage of this function over 
        mmse2interval is that this one is more flexible in the use of the 
        structuring elements as they are not required to have the same 
        size.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmse2interval}
    \index{multireg.num\_pymorph \textit{(module)}!mmse2interval \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmse2interval}(\textit{a}, \textit{b})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Create an interval from a pair of structuring elements.

      \item Synopsis Iab = mmse2interval(a, b)

      \item Input a: Structuring Element Left extremity. b: Structuring 
        Element Right extremity.

      \item Output Iab: Interval

      \item Description mmse2interval creates the interval [a,b] from the 
        structuring elements a and b such that a is less or equal b .

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsebox}
    \index{multireg.num\_pymorph \textit{(module)}!mmsebox \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsebox}(\textit{r}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Create a box structuring element.

      \item Synopsis B = mmsebox(r=1)

      \item Input r: Non-negative integer. Default: 1. Radius.

      \item Output B: Structuring Element

      \item Description mmsebox creates the structuring element B formed by r 
        successive Minkowski additions of the elementary square (i.e., 
        the 3x3 square centered at the origin) with itself. If R=0, B is 
        the unitary set that contains the origin. If R=1, B is the 
        elementary square itself.

      \item Examples \# b1 = mmsebox() mmseshow(b1) b2 = mmsebox(2) 
        mmseshow(b2)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsecross}
    \index{multireg.num\_pymorph \textit{(module)}!mmsecross \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsecross}(\textit{r}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Diamond structuring element and elementary 3x3 cross.

      \item Synopsis B = mmsecross(r=1)

      \item Input r: Double Default: 1. (radius).

      \item Output B: Structuring Element

      \item Description mmsecross creates the structuring element B formed by 
        r successive Minkowski additions of the elementary cross (i.e., 
        the 3x3 cross centered at the origin) with itself. If r=0, B is 
        the unitary set that contains the origin. If r=1 , B is the 
        elementary cross itself.

      \item Examples \# b1 = mmsecross() print mmseshow(b1) b2 = mmsecross(2) 
        print mmseshow(b2)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsedil}
    \index{multireg.num\_pymorph \textit{(module)}!mmsedil \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsedil}(\textit{B1}, \textit{B2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Dilate one structuring element by another

      \item Synopsis Bo = mmsedil(B1, B2)

      \item Input B1: Structuring Element B2: Structuring Element

      \item Output Bo: Structuring Element

      \item Description mmsedil dilates an structuring element by another. 
        The main difference between this dilation and mmdil is that the 
        dilation between structuring elements are not bounded, returning 
        another structuring element usually larger than anyone of them. 
        This gives the composition of the two structuring elements by 
        Minkowski addition.

      \item Examples \# b1 = mmseline(5) mmseshow(b1) b2 = mmsedisk(2) 
        mmseshow(b2) b3 = mmsedil(b1,b2) mmseshow(b3)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsedisk}
    \index{multireg.num\_pymorph \textit{(module)}!mmsedisk \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsedisk}(\textit{r}=\texttt{3\-}, \textit{DIM}=\texttt{'\-2\-D\-'\-}, \textit{METRIC}=\texttt{'\-E\-U\-C\-L\-I\-D\-E\-A\-N\-'\-}, \textit{FLAT}=\texttt{'\-F\-L\-A\-T\-'\-}, \textit{h}=\texttt{0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Create a disk or a semi-sphere structuring element.
- Synopsis
    B = mmsedisk(r=3, DIM="2D", METRIC="EUCLIDEAN", FLAT="FLAT",
    h=0)
- Input
    r:      Non-negative integer. Default: 3. Disk radius.
    DIM:    String Default: "2D". '1D', '2D, or '3D'.
    METRIC: String Default: "EUCLIDEAN". 'EUCLIDEAN', ' CITY-BLOCK',
            'OCTAGON', or ' CHESSBOARD'.
    FLAT:   String Default: "FLAT". 'FLAT' or 'NON-FLAT'.
    h:      Double Default: 0. Elevation of the center of the
            semi-sphere.
- Output
    B: Structuring Element
- Description
    mmsedisk creates a flat structuring element B that is disk under
    the metric METRIC , centered at the origin and with radius r or
    a non-flat structuring element that is a semi-sphere under the
    metric METRIC, centered at (0, h) and with radius r . This
    structuring element can be created on the 1D, 2D or 3D space.
- Examples
    \#
    \#   example 1
    \#
    a=mmseshow(mmsedisk(10,'2D','CITY-BLOCK'))
    b=mmseshow(mmsedisk(10,'2D','EUCLIDEAN'))
    c=mmseshow(mmsedisk(10,'2D','OCTAGON'))
    mmshow(a)
    mmshow(b)
    mmshow(c)
    \#
    \#   example 2
    \#
    d=mmseshow(mmsedisk(10,'2D','CITY-BLOCK','NON-FLAT'))
    e=mmseshow(mmsedisk(10,'2D','EUCLIDEAN','NON-FLAT'))
    f=mmseshow(mmsedisk(10,'2D','OCTAGON','NON-FLAT'))
    mmshow(d)
    mmshow(e)
    mmshow(f)
    \#
    \#   example 3
    \#
    g=mmsedisk(3,'2D','EUCLIDEAN','NON-FLAT')
    mmseshow(g)
    h=mmsedisk(3,'2D','EUCLIDEAN','NON-FLAT',5)
    mmseshow(h)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmseline}
    \index{multireg.num\_pymorph \textit{(module)}!mmseline \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmseline}(\textit{l}=\texttt{3\-}, \textit{theta}=\texttt{0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Create a line structuring element.

      \item Synopsis B = mmseline(l=3, theta=0)

      \item Input l: Non-negative integer. Default: 3. theta: Double Default: 
        0. (degrees, clockwise)

      \item Output B: Structuring Element

      \item Description mmseline creates a structuring element B that is a 
        line segment that has an extremity at the origin, length l and 
        angle theta (0 degrees is east direction, clockwise). If l=0 , it 
        generates the origin.

      \item Examples \# mmseshow(mmseline()) b1 = mmseline(4,45) mmseshow(b1) 
        b2 = mmseline(4,-180) mmseshow(b2) a=mmtext('Line') b=mmdil(a,b1) 
        mmshow(a) mmshow(b)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsereflect}
    \index{multireg.num\_pymorph \textit{(module)}!mmsereflect \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsereflect}(\textit{Bi})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Reflect a structuring element

      \item Synopsis Bo = mmsereflect(Bi)

      \item Input Bi: Structuring Element

      \item Output Bo: Structuring Element

      \item Description mmsereflect reflects a structuring element by 
        rotating it 180 degrees.

      \item Examples \# b1 = mmseline(5,30) print mmseshow(b1) b2 = 
        mmsereflect(b1) print mmseshow(b2)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmserot}
    \index{multireg.num\_pymorph \textit{(module)}!mmserot \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmserot}(\textit{B}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Rotate a structuring element.
- Synopsis
    BROT = mmserot(B, theta=45, DIRECTION="CLOCKWISE")
- Input
    B:         Structuring Element
    theta:     Double Default: 45. Degrees of rotation. Available
               values are multiple of 45 degrees.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'.
- Output
    BROT: Structuring Element
- Description
    mmserot rotates a structuring element B of an angle theta .
- Examples
    \#
    b = mmimg2se(mmbinary([[0, 0, 0], [0, 1, 1], [0, 0, 0]]));
    mmseshow(b)
    mmseshow(mmserot(b))
    mmseshow(mmserot(b,45,'ANTI-CLOCKWISE'))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmseshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmseshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmseshow}(\textit{B}, \textit{option}=\texttt{'\-N\-O\-R\-M\-A\-L\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Display a structuring element as an image.
- Synopsis
    y = mmseshow(B, option="NORMAL")
- Input
    B:      Structuring Element
    option: String Default: "NORMAL". 'NORMAL', ' EXPAND' or '
            NON-FLAT'
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmseshow used with the option EXPAND generates an image y that
    is a suitable graphical representation of the structuring
    element B . This function is useful to convert a structuring
    element to an image. The origin of the structuring element is at
    the center of the image. If B is flat, y is binary, otherwise, y
    is signed int32 image. When using the option NON-FLAT, the
    output y is always a signed int32 image.
- Examples
    \#
    \#   example 1
    \#
    b=mmsecross(3);
    print mmseshow(b)
    a = mmseshow(b,'EXPAND')
    mmshow(a)
    print mmseshow(b,'NON-FLAT')
    \#
    \#   example 2
    \#
    b=mmsedisk(2,'2D','EUCLIDEAN','NON-FLAT')
    print mmseshow(b)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsesum}
    \index{multireg.num\_pymorph \textit{(module)}!mmsesum \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsesum}(\textit{B}=\texttt{N\-o\-n\-e\-}, \textit{N}=\texttt{1\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose N-1 iterative Minkowski additions

      \item Synopsis NB = mmsesum(B=None, N=1)

      \item Input B: Structuring Element Default: None (3x3 elementary 
        cross). N: Non-negative integer. Default: 1.

      \item Output NB: Structuring Element

      \item Description mmsesum creates the structuring element NB from N - 1 
        iterative Minkowski additions with the structuring element B .

      \item Examplesdef mmsesum \# \# example 1 \# b = mmimg2se(mmbinary([[1, 
        1, 1], [1, 1, 1], [0, 1, 0]])) mmseshow(b) b3 = mmsesum(b,3) 
        mmseshow(b3) \# \# example 2 \# b = 
        mmsedisk(1,'2D','CITY-BLOCK','NON-FLAT'); mmseshow(b) 
        mmseshow(mmsesum(b,2))

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmset2mat}
    \index{multireg.num\_pymorph \textit{(module)}!mmset2mat \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmset2mat}(\textit{A})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Converts image representation from set to matrix
- Synopsis
    M = mmset2mat(A)
- Input
    A: Tuple with array of pixel coordinates and optional array of
       corresponding pixel values
- Output
    M: Image in matrix format, origin (0,0) at the matrix center
- Description
    Return an image in the matrix format built from a tuple of an
    array of pixel coordinates and a corresponding array of pixel
    values
- Examples
    \#
    coord=int32([
      [ 0,0],
      [-1,0],
      [ 1,1]])
    A=mmset2mat((coord,))
    print A
    print mmdatatype(A)
    vu = uint8([1,2,3])
    f=mmset2mat((coord,vu))
    print f
    print mmdatatype(f)
    vi = int32([1,2,3])
    g=mmset2mat((coord,vi))
    print g
    print mmdatatype(g)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsetrans}
    \index{multireg.num\_pymorph \textit{(module)}!mmsetrans \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsetrans}(\textit{Bi}, \textit{t})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Translate a structuring element

      \item Synopsis Bo = mmsetrans(Bi, t)

      \item Input Bi: Structuring Element t:

      \item Output Bo: Structuring Element

      \item Description mmsetrans translates a structuring element by a 
        specific value.

      \item Examples \# b1 = mmseline(5) mmseshow(b1) b2 = 
        mmsetrans(b1,[2,-2]) mmseshow(b2)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmseunion}
    \index{multireg.num\_pymorph \textit{(module)}!mmseunion \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmseunion}(\textit{B1}, \textit{B2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Union of structuring elements

      \item Synopsis B = mmseunion(B1, B2)

      \item Input B1: Structuring Element B2: Structuring Element

      \item Output B: Structuring Element

      \item Description mmseunion creates a structuring element from the 
        union of two structuring elements.

      \item Examples \# b1 = mmseline(5) mmseshow(b1) b2 = mmsedisk(3) 
        mmseshow(b2) b3 = mmseunion(b1,b2) mmseshow(b3)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmshow}
    \index{multireg.num\_pymorph \textit{(module)}!mmshow \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmshow}(\textit{f}, \textit{f1}=\texttt{N\-o\-n\-e\-}, \textit{f2}=\texttt{N\-o\-n\-e\-}, \textit{f3}=\texttt{N\-o\-n\-e\-}, \textit{f4}=\texttt{N\-o\-n\-e\-}, \textit{f5}=\texttt{N\-o\-n\-e\-}, \textit{f6}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Display binary or gray-scale images and optionally 
        overlay it with binary images.

      \item Synopsis mmshow(f, f1=None, f2=None, f3=None, f4=None, f5=None, 
        f6=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. f1: Binary 
        image. Default: None. Red overlay. f2: Binary image. Default: 
        None. Green overlay. f3: Binary image. Default: None. Blue 
        overlay. f4: Binary image. Default: None. Magenta overlay. f5: 
        Binary image. Default: None. Yellow overlay. f6: Binary image. 
        Default: None. Cyan overlay.

      \item Description Displays the binary or gray-scale (uint8 or uint16) 
        image f , and optionally overlay it with up to six binary images 
        f1 to f6 in the following colors: f1 as red, f2 as green, f3 as 
        blue, f4 as yellow, f5 as magenta, and f6 as cian. The image is 
        displayed in the MATLAB figure only if no output parameter is 
        given.

      \item Examples \# f=mmreadgray('mribrain.tif'); f150=mmthreshad(f,150); 
        f200=mmthreshad(f,200); mmshow(f); mmshow(f150); 
        mmshow(f,f150,f200);

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmskelm}
    \index{multireg.num\_pymorph \textit{(module)}!mmskelm \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmskelm}(\textit{f}, \textit{B}=\texttt{N\-o\-n\-e\-}, \textit{option}=\texttt{'\-b\-i\-n\-a\-r\-y\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Morphological skeleton (Medial Axis Transform).
- Synopsis
    y = mmskelm(f, B=None, option="binary")
- Input
    f:      Binary image.
    B:      Structuring Element Default: None (3x3 elementary
            cross).
    option: String Default: "binary". Choose one of: binary: output
            a binary image (medial axis); value: output a grayscale
            image with values of the radius of the disk to
            reconstruct the original image (medial axis transform).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmskelm creates the image y by computing the morphological
    skeleton by B of the image f , when option is BINARY. In this
    case, the pixels of value 1 in y are center of maximal balls
    (generated from B ) included in f . This is also called Medial
    Axis. If option is VALUE, the non zeros pixels in y are the
    radius plus 1 of the maximal balls. This is called Medial Axis
    Transform or valued morphological skeleton.
- Examples
    \#
    \#   example 1
    \#
    from Numeric import ones
    a=mmneg(mmframe(mmbinary(ones((7,9)))))
    print a
    print mmskelm(a)
    print mmskelm(a,mmsebox())
    \#
    \#   example 2
    \#
    a=mmreadgray('pcbholes.tif')
    b=mmskelm(a)
    mmshow(a)
    mmshow(b)
    \#
    \#   example 3
    \#
    c=mmskelm(a,mmsecross(),'value')
    mmshow(c)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmskelmrec}
    \index{multireg.num\_pymorph \textit{(module)}!mmskelmrec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmskelmrec}(\textit{f}, \textit{B}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Morphological skeleton reconstruction (Inverse Medial 
        Axis Transform).

      \item Synopsis y = mmskelmrec(f, B=None)

      \item Input f: Gray-scale (uint8 or uint16) or binary image. B: 
        Structuring Element Default: None (3x3 elementary cross).

      \item Output y: Binary image.

      \item Description mmskelmrec reconstructs the valued morphological 
        skeleton to recover the original image.

      \item Examples \# from Numeric import ones 
        a=mmneg(mmframe(mmbinary(ones((7,9))))) print a 
        b=mmskelm(a,mmsecross(),'value') print b 
        c=mmskelmrec(b,mmsecross()) print c

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmskiz}
    \index{multireg.num\_pymorph \textit{(module)}!mmskiz \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmskiz}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{LINEREG}=\texttt{'\-L\-I\-N\-E\-S\-'\-}, \textit{METRIC}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Skeleton of Influence Zone - also know as Generalized Voronoi
    Diagram
- Synopsis
    y = mmskiz(f, Bc=None, LINEREG="LINES", METRIC=None)
- Input
    f:       Binary image.
    Bc:      Structuring Element Default: None (3x3 elementary
             cross). Connectivity for the distance measurement.
    LINEREG: String Default: "LINES". 'LINES' or 'REGIONS'.
    METRIC:  String Default: None. 'EUCLIDEAN' if specified.
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmskiz creates the image y by detecting the lines which are
    equidistant to two or more connected components of f , according
    to the connectivity defined by Bc . Depending on with the flag
    LINEREG, y will be a binary image with the skiz lines or a
    labeled image representing the zone of influence regions. When
    the connected objects of f are single points, the skiz is the
    Voronoi diagram.
- Examples
    \#
    \#   example 1
    \#
    f=mmreadgray('blob2.tif')
    y=mmskiz(f,mmsebox(),'LINES','EUCLIDEAN')
    mmshow(f,y)
    \#
    \#   example 2
    \#
    from Numeric import zeros
    f=mmbinary(zeros((100,100)))
    f[30,25],f[20,75],f[50,50],f[70,30],f[80,70] = 1,1,1,1,1
    y = mmskiz(f,mmsebox(),'LINES','EUCLIDEAN')
    mmshow(f,y)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmstats}
    \index{multireg.num\_pymorph \textit{(module)}!mmstats \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmstats}(\textit{f}, \textit{measurement})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Find global image statistics.
- Synopsis
    y = mmstats(f, measurement)
- Input
    f:           
    measurement: String Default: "". Choose the measure to compute:
                 'max', 'min', 'median', 'mean', 'sum', 'std',
                 'std1'.
- Output
    y:
- Description
    Compute global image statistics: 'max' - maximum gray-scale
    value in image; 'min' - minimum gray-scale value in image; 'sum'
    - sum of all pixel values; 'median' - median value of all pixels
    in image; 'mean' - mean value of all pixels in image; 'std' -
    standard deviation of all pixels (normalized by N-1); 'std1' -
    idem, normalized by N.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsubm}
    \index{multireg.num\_pymorph \textit{(module)}!mmsubm \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsubm}(\textit{f1}, \textit{f2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Subtraction of two images, with saturation.
- Synopsis
    y = mmsubm(f1, f2)
- Input
    f1: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image.
    f2: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image. Or constant.
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmsubm creates the image y by pixelwise subtraction of the image
    f2 from the image f1 . When the subtraction of the values of two
    pixels is negative, 0 is taken as the result of the subtraction.
    When f1 and f2 are binary images, y represents the set
    subtraction of f2 from f1 .
- Examples
    \#
    \#   example 1
    \#
    f = uint8([255,   255,    0,   10,   20,   10,    0,   255,  255])
    g = uint8([10,     20,   30,   40,   50,   40,   30,    20,    10])
    print mmsubm(f, g)
    print mmsubm(f, 100)
    print mmsubm(100, f)
    \#
    \#   example 2
    \#
    a = mmreadgray('boxdrill-C.tif')
    b = mmreadgray('boxdrill-B.tif')
    c = mmsubm(a,b)
    mmshow(a)
    mmshow(b)
    mmshow(c)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsubm_old}
    \index{multireg.num\_pymorph \textit{(module)}!mmsubm\_old \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsubm\_old}(\textit{f1}, \textit{f2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Subtraction of two images, with saturation.
- Synopsis
    y = mmsubm(f1, f2)
- Input
    f1: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image.
    f2: Unsigned gray-scale (uint8 or uint16), signed (int32) or
        binary image. Or constant.
- Output
    y: Unsigned gray-scale (uint8 or uint16), signed (int32) or
       binary image.
- Description
    mmsubm creates the image y by pixelwise subtraction of the image
    f2 from the image f1 . When the subtraction of the values of two
    pixels is negative, 0 is taken as the result of the subtraction.
    When f1 and f2 are binary images, y represents the set
    subtraction of f2 from f1 .
- Examples
    \#
    \#   example 1
    \#
    f = uint8([255,   255,    0,   10,   20,   10,    0,   255,  255])
    g = uint8([10,     20,   30,   40,   50,   40,   30,    20,    10])
    print mmsubm(f, g)
    print mmsubm(f, 100)
    print mmsubm(100, f)
    \#
    \#   example 2
    \#
    a = mmreadgray('boxdrill-C.tif')
    b = mmreadgray('boxdrill-B.tif')
    c = mmsubm(a,b)
    mmshow(a)
    mmshow(b)
    mmshow(c)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsupcanon}
    \index{multireg.num\_pymorph \textit{(module)}!mmsupcanon \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsupcanon}(\textit{f}, \textit{Iab}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Union of sup-generating or hit-miss operators.
- Synopsis
    y = mmsupcanon(f, Iab, theta=45, DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    Iab:       Interval
    theta:     Double Default: 45. Degrees of rotation: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'
- Output
    y: Binary image.
- Description
    mmsupcanon creates the image y by computing the union of
    transformations of the image f by sup-generating operators.
    These hit-miss operators are characterized by rotations (in the
    clockwise or anti-clockwise direction) of theta degrees of the
    interval Iab .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsupgen}
    \index{multireg.num\_pymorph \textit{(module)}!mmsupgen \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsupgen}(\textit{f}, \textit{INTER})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Sup-generating (hit-miss).
- Synopsis
    y = mmsupgen(f, INTER)
- Input
    f:     Binary image.
    INTER: Interval
- Output
    y: Binary image.
- Description
    mmsupgen creates the binary image y by computing the
    transformation of the image f by the sup-generating operator
    characterized by the interval Iab . The sup-generating operator
    is just a relaxed template matching, where the criterion to keep
    a shape is that it be inside the interval Iab . Note that we
    have the classical template matching when a=b . Note yet that
    the sup-generating operator is equivalent to the classical
    hit-miss operator.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [0,0,1,0,0,1,1],
       [0,1,0,0,1,0,0],
       [0,0,0,1,1,0,0]])
    i=mmendpoints()
    print mmintershow(i)
    g=mmsupgen(f,i)
    print g
    \#
    \#   example 2
    \#
    a=mmreadgray('gear.tif')
    b=mmsupgen(a,mmendpoints())
    mmshow(a)
    mmshow(mmdil(b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsupgen_old}
    \index{multireg.num\_pymorph \textit{(module)}!mmsupgen\_old \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsupgen\_old}(\textit{f}, \textit{INTER})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Sup-generating (hit-miss).
- Synopsis
    y = mmsupgen(f, INTER)
- Input
    f:     Binary image.
    INTER: Interval
- Output
    y: Binary image.
- Description
    mmsupgen creates the binary image y by computing the
    transformation of the image f by the sup-generating operator
    characterized by the interval Iab . The sup-generating operator
    is just a relaxed template matching, where the criterion to keep
    a shape is that it be inside the interval Iab . Note that we
    have the classical template matching when a=b . Note yet that
    the sup-generating operator is equivalent to the classical
    hit-miss operator.
- Examples
    \#
    \#   example 1
    \#
    f=mmbinary([
       [0,0,1,0,0,1,1],
       [0,1,0,0,1,0,0],
       [0,0,0,1,1,0,0]])
    i=mmendpoints()
    print mmintershow(i)
    g=mmsupgen(f,i)
    print g
    \#
    \#   example 2
    \#
    a=mmreadgray('gear.tif')
    b=mmsupgen(a,mmendpoints())
    mmshow(a)
    mmshow(mmdil(b))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsuprec}
    \index{multireg.num\_pymorph \textit{(module)}!mmsuprec \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsuprec}(\textit{f}, \textit{g}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Sup-reconstruction.
- Synopsis
    y = mmsuprec(f, g, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) or binary image. Marker image.
    g:  Gray-scale (uint8 or uint16) or binary image. Conditioning
        image.
    Bc: Structuring Element Default: None (3x3 elementary cross). (
        connectivity).
- Output
    y: Image
- Description
    mmsuprec creates the image y by an infinite number of recursive
    iterations (iterations until stability) of the erosion of f by
    Bc conditioned to g . We say that y is the sup-reconstruction of
    g from the marker f .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmswatershed}
    \index{multireg.num\_pymorph \textit{(module)}!mmswatershed \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmswatershed}(\textit{f}, \textit{g}, \textit{B}=\texttt{N\-o\-n\-e\-}, \textit{LINEREG}=\texttt{'\-L\-I\-N\-E\-S\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Detection of similarity-based watershed from markers.
- Synopsis
    y = mmswatershed(f, g, B=None, LINEREG="LINES")
- Input
    f:       Gray-scale (uint8 or uint16) image.
    g:       Gray-scale (uint8 or uint16) or binary image. Marker
             image. If binary, each connected component is an object
             marker. If gray, it is assumed it is a labeled image.
    B:       Structuring Element Default: None (3x3 elementary
             cross). (watershed connectivity)
    LINEREG: String Default: "LINES". 'LINES' or ' REGIONS'.
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmswatershed creates the image y by detecting the domain of the
    catchment basins of f indicated by g , according with the
    connectivity defined by B . This watershed is a modified version
    where each basin is defined by a similarity criterion between
    pixels. The original watershed is normally applied to the
    gradient of the image. In this case, the gradient is taken
    internally. According to the flag LINEREG y will be a labeled
    image of the catchment basins domain or just a binary image that
    presents the watershed lines. The implementation of this
    function is based on LotuFalc:00 .
- Examples
    \#
    f = uint8([
        [0,  0,  0,  0,  0,  0,  0],
        [0,  1,  0,  0,  0,  1,  0],
        [0,  1,  0,  0,  0,  1,  0],
        [0,  1,  1,  1,  1,  1,  0],
        [0,  1,  0,  0,  0,  0,  0],
        [0,  0,  0,  0,  0,  0,  0]])
    m = uint8([
        [0,  0,  0,  0,  0,  0,  0],
        [0,  1,  0,  0,  0,  0,  0],
        [0,  0,  0,  0,  0,  0,  0],
        [0,  0,  0,  0,  0,  0,  0],
        [0,  0,  0,  0,  0,  0,  0],
        [0,  0,  0,  2,  0,  0,  0]])
    print mmswatershed(f,m,mmsecross(),'REGIONS')\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmsymdif}
    \index{multireg.num\_pymorph \textit{(module)}!mmsymdif \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmsymdif}(\textit{f1}, \textit{f2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Symmetric difference between two images

      \item Synopsis y = mmsymdif(f1, f2)

      \item Input f1: Gray-scale (uint8 or uint16) or binary image. f2: 
        Gray-scale (uint8 or uint16) or binary image.

      \item Output y: Image i

      \item Description mmsymdif creates the image y by taken the union of 
        the subtractions of f1 from f2 and f2 from f1 . When f1 and f2 
        are binary images, y represents the set of points that are in f1 
        and not in f2 or that are in f2 and not in f1 .

      \item Examples \# \# example 1 \# a = uint8([1, 2, 3, 4, 5]) b = 
        uint8([5, 4, 3, 2, 1]) print mmsymdif(a,b) \# \# example 2 \# c = 
        mmreadgray('tplayer1.tif') d = mmreadgray('tplayer2.tif') e = 
        mmsymdif(c,d) mmshow(c) mmshow(d) mmshow(e)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmtext}
    \index{multireg.num\_pymorph \textit{(module)}!mmtext \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmtext}(\textit{txt})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Create a binary image of a text.

      \item Synopsis y = mmtext(txt)

      \item Input txt: String Default: "". Text to be written.

      \item Output y: Binary image.

      \item Description mmtext creates the binary image y of the text txt . 
        The background of y is 0, while its foreground is 1. The text 
        should be composed only by lower and upper case letters.

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmthick}
    \index{multireg.num\_pymorph \textit{(module)}!mmthick \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmthick}(\textit{f}, \textit{Iab}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{-\-1\-}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Image transformation by thickening.
- Synopsis
    y = mmthick(f, Iab=None, n=-1, theta=45, DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    Iab:       Interval Default: None (mmhomothick).
    n:         Non-negative integer. Default: -1. Number of
               iterations.
    theta:     Double Default: 45. Degrees of rotation: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'
- Output
    y: Binary image.
- Description
    mmthick creates the binary image y by performing a thickening of
    the binary image f . The number of iterations of the thickening
    is n and each iteration is performed by union of f with the
    points that are detected in f by the hit-miss operators
    characterized by rotations of theta degrees of the interval Iab
    .\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmthin}
    \index{multireg.num\_pymorph \textit{(module)}!mmthin \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmthin}(\textit{f}, \textit{Iab}=\texttt{N\-o\-n\-e\-}, \textit{n}=\texttt{-\-1\-}, \textit{theta}=\texttt{4\-5\-}, \textit{DIRECTION}=\texttt{'\-C\-L\-O\-C\-K\-W\-I\-S\-E\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Image transformation by thinning.
- Synopsis
    y = mmthin(f, Iab=None, n=-1, theta=45, DIRECTION="CLOCKWISE")
- Input
    f:         Binary image.
    Iab:       Interval Default: None (mmhomothin).
    n:         Non-negative integer. Default: -1. Number of
               iterations.
    theta:     Double Default: 45. Degrees of rotation: 45, 90, or
               180.
    DIRECTION: String Default: "CLOCKWISE". 'CLOCKWISE' or '
               ANTI-CLOCKWISE'
- Output
    y: Binary image.
- Description
    mmthin creates the binary image y by performing a thinning of
    the binary image f . The number of iterations of the thinning is
    n and each iteration is performed by subtracting the points that
    are detect in f by hit-miss operators characterized by rotations
    of theta of the interval Iab . When n is infinite and the
    interval is mmhomothin (default conditions), mmthin gives the
    skeleton by thinning.
- Examples
    \#
    f=mmreadgray('scissors.tif')
    f1=mmthin(f)
    mmshow(f,f1) \# skeleton
    f2=mmthin(f1,mmendpoints(),15) \# prunning 15 pixels
    mmshow(f,f2) \# prunned skeleton\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmthreshad}
    \index{multireg.num\_pymorph \textit{(module)}!mmthreshad \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmthreshad}(\textit{f}, \textit{f1}, \textit{f2}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Threshold (adaptive)
- Synopsis
    y = mmthreshad(f, f1, f2=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    f1: Gray-scale (uint8 or uint16) image. lower value
    f2: Gray-scale (uint8 or uint16) image. Default: None. upper
        value
- Output
    y: Binary image.
- Description
    mmthreshad creates the image y as the threshold of the image f
    by the images f1 and f2 . A pixel in y has the value 1 when the
    value of the corresponding pixel in f is between the values of
    the corresponding pixels in f1 and f2 .
- Examples
    \#
    a = mmreadgray('keyb.tif')
    mmshow(a)
    b = mmthreshad(a,uint8(10), uint8(50))
    mmshow(b)
    c = mmthreshad(a,238)
    mmshow(c)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmtoggle}
    \index{multireg.num\_pymorph \textit{(module)}!mmtoggle \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmtoggle}(\textit{f}, \textit{f1}, \textit{f2}, \textit{OPTION}=\texttt{'\-G\-R\-A\-Y\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Image contrast enhancement or classification by the 
        toggle operator.

      \item Synopsis y = mmtoggle(f, f1, f2, OPTION="GRAY")

      \item Input f: Gray-scale (uint8 or uint16) image. f1: Gray-scale 
        (uint8 or uint16) image. f2: Gray-scale (uint8 or uint16) image. 
        OPTION: String Default: "GRAY". Values: 'BINARY' or 'GRAY'.

      \item Output y: Image binary image if option is 'BINARY' or same type 
        as f

      \item Description mmtoggle creates the image y that is an enhancement 
        or classification of the image f by the toggle operator, with 
        parameters f1 and f2 . If the OPTION is 'GRAY', it performs an 
        enhancement and, if the OPTION is 'BINARY', it performs a binary 
        classification. In the enhancement, a pixel takes the value of 
        the corresponding pixel in f1 or f2 , according to a minimum 
        distance criterion from f to f1 or f to f2 . In the 
        classification, the pixels in f nearest to f1 receive the value 0 
        , while the ones nearest to f2 receive the value 1.

      \item Examples \# \# example 1 \# f = uint8([0,1,2,3,4,5,6]) print f f1 
        = uint8([0,0,0,0,0,0,0]) print f1 f2 = uint8([6,6,6,6,6,6,6]) 
        print f2 print mmtoggle(f,f1,f2) \# \# example 2 \# a = 
        mmreadgray('angiogr.tif') b = mmero(a,mmsedisk(2)) c = 
        mmdil(a,mmsedisk(2)) d = mmtoggle(a,b,c) mmshow(a) mmshow(d) \# 
        \# example 3 \# e = mmreadgray('lenina.tif') f = 
        mmero(e,mmsedisk(2)) g = mmdil(e,mmsedisk(2)) h = 
        mmtoggle(e,f,g,'BINARY') mmshow(e) mmshow(h)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmunion}
    \index{multireg.num\_pymorph \textit{(module)}!mmunion \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmunion}(\textit{f1}, \textit{f2}, \textit{f3}=\texttt{N\-o\-n\-e\-}, \textit{f4}=\texttt{N\-o\-n\-e\-}, \textit{f5}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Union of images.
- Synopsis
    y = mmunion(f1, f2, f3=None, f4=None, f5=None)
- Input
    f1: Gray-scale (uint8 or uint16) or binary image.
    f2: Gray-scale (uint8 or uint16) or binary image. Or constant
    f3: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
    f4: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
    f5: Gray-scale (uint8 or uint16) or binary image. Default: None.
        Or constant.
- Output
    y: Image
- Description
    mmunion creates the image y by taking the pixelwise maximum
    between the images f1, f2, f3, f4, and f5 . When f1, f2, f3, f4,
    and f5 are binary images, y represents the union of them.
- Examples
    \#
    \#   example 1
    \#
    f=uint8([255, 255,  0,  10,   0, 255, 250])
    print 'f=',f
    g=uint8([  0,  40, 80, 140, 250,  10,  30])
    print 'g=',g
    print mmunion(f, g)
    print mmunion(f, 255)
    \#
    \#   example 2
    \#
    a = mmreadgray('form-ok.tif')
    b = mmreadgray('form-1.tif')
    c = mmunion(a,b)
    mmshow(a)
    mmshow(b)
    mmshow(c)
    \#
    \#   example 3
    \#
    d = mmreadgray('danaus.tif')
    e = mmcmp(d,'{\textless}',80)
    f = mmunion(d,mmgray(e))
    mmshow(d)
    mmshow(e)
    mmshow(f)
    \#
    \#   example 4
    \#
    g = mmreadgray('tplayer1.tif')
    h = mmreadgray('tplayer2.tif')
    i = mmreadgray('tplayer3.tif')
    j = mmunion(g,h,i)
    mmshow(g)
    mmshow(h)
    mmshow(i)
    mmshow(j)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmvdome}
    \index{multireg.num\_pymorph \textit{(module)}!mmvdome \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmvdome}(\textit{f}, \textit{v}=\texttt{1\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Obsolete, use mmvmax.
- Synopsis
    y = mmvdome(f, v=1, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    v:  Default: 1. Volume parameter.
    Bc: Structuring Element Default: None (3x3 elementary cross).
        Structuring element (connectivity).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    The correct name for this operator mmvdome is mmvmax.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmversion}
    \index{multireg.num\_pymorph \textit{(module)}!mmversion \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmversion}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose SDC Morphology Toolbox version.

      \item Synopsis S = mmversion()

      \item Output S: String ( description of the version).

      \item Description mmversion gives the SDC Morphology Toolbox version.

      \item Examples \# print mmversion()

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmvmax}
    \index{multireg.num\_pymorph \textit{(module)}!mmvmax \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmvmax}(\textit{f}, \textit{v}=\texttt{1\-}, \textit{Bc}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Remove domes with volume less than v.
- Synopsis
    y = mmvmax(f, v=1, Bc=None)
- Input
    f:  Gray-scale (uint8 or uint16) image.
    v:  Default: 1. Volume parameter.
    Bc: Structuring Element Default: None (3x3 elementary cross).
        Structuring element (connectivity).
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmvmax This operator removes connected domes with volume less
    than v . This function is very similar to mmhmax , but instead
    of using a gray scale criterion (contrast) for the dome, it uses
    a volume criterion.
- Examples
    \#
    \#   example 1
    \#
    a = uint8([
        [4,  3,  6,  1,  3,  5,  2],
        [2,  9,  6,  1,  6,  7,  3],
        [8,  9,  3,  2,  4,  9,  4],
        [3,  1,  2,  1,  2,  4,  2]])
    print mmvmax(a,10,mmsebox())
    \#
    \#   example 2
    \#
    f = mmreadgray('astablet.tif')
    mmshow(f)
    fb = mmvmax(f,80000)
    mmshow(fb)
    mmshow(mmregmax(fb))\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:mmwatershed}
    \index{multireg.num\_pymorph \textit{(module)}!mmwatershed \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{mmwatershed}(\textit{f}, \textit{Bc}=\texttt{N\-o\-n\-e\-}, \textit{LINEREG}=\texttt{'\-L\-I\-N\-E\-S\-'\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
- Purpose
    Watershed detection.
- Synopsis
    y = mmwatershed(f, Bc=None, LINEREG="LINES")
- Input
    f:       Gray-scale (uint8 or uint16) or binary image.
    Bc:      Structuring Element Default: None (3x3 elementary
             cross). ( connectivity)
    LINEREG: String Default: "LINES". 'LINES' or ' REGIONS'.
- Output
    y: Gray-scale (uint8 or uint16) or binary image.
- Description
    mmwatershed creates the image y by detecting the domain of the
    catchment basins of f , according to the connectivity defined by
    Bc . According to the flag LINEREG y will be a labeled image of
    the catchment basins domain or just a binary image that presents
    the watershed lines. The implementation of this function is
    based on VincSoil:91 .
- Examples
    \#
    f=mmreadgray('astablet.tif')
    grad=mmgradm(f)
    w1=mmwatershed(grad,mmsebox())
    w2=mmwatershed(grad,mmsebox(),'REGIONS')
    mmshow(grad)
    mmshow(w1)
    mmlblshow(w2)\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:sign}
    \index{multireg.num\_pymorph \textit{(module)}!sign \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{sign}(\textit{val})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Determine the sign of a numeric value.

      \item Synopsis B = sign(val)

      \item Input val: scalar numeric value

      \item Output B: -1,0,1 depending on sign of numeric input

      \item Description sign determines the numeric sign of the input value, 
        assigning a value of -1 for negative values, 1 for positive 
        values and 0 for 0.

      \item Examples \# b1 = sign(-4) print b1 b2 = sign(0.1) print b2 b3 = 
        sign(0) print b3

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:uint16}
    \index{multireg.num\_pymorph \textit{(module)}!uint16 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{uint16}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Convert an image to a uint16 image.

      \item Synopsis img = uint16(f)

      \item Input f: Any image

      \item Output img: The converted image

      \item Description uint16 clips the input image between the values 0 and 
        65535 and converts it to the unsigned 16-bit datatype.

      \item Examples \# a = int32([-3,0,8,100000]) print uint16(a)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:num_pymorph:uint8}
    \index{multireg.num\_pymorph \textit{(module)}!uint8 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{uint8}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Purpose Convert an image to an uint8 image.

      \item Synopsis img = uint8(f)

      \item Input f: Any image

      \item Output img: Gray-scale uint8 image. The converted image

      \item Description uint8 clips the input image between the values 0 and 
        255 and converts it to the unsigned 8-bit datatype.

      \item Examples \# a = int32([-3,0,8,600]) print uint8(a)

    \end{itemize}

    \vspace{1ex}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-b\-u\-i\-l\-d\-\_\-d\-a\-t\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt '\-0\-4\-a\-u\-g\-2\-0\-0\-3\-~\-1\-2\-:\-0\-7\-'\-}            \textit{(type=\texttt{str})}&\\
\cline{1-2}
\raggedright \_\-\_\-f\-i\-g\-s\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt [\-N\-o\-n\-e\-]\-}            \textit{(type=\texttt{list})}&\\
\cline{1-2}
\raggedright \_\-\_\-v\-e\-r\-s\-i\-o\-n\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt '\-0\-.\-8\-.\-1\-~\-n\-u\-m\-b\-a\-s\-e\-'\-}            \textit{(type=\texttt{str})}&\\
\cline{1-2}
\raggedright \_\-\_\-v\-e\-r\-s\-i\-o\-n\-\_\-s\-t\-r\-i\-n\-g\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt '\-S\-D\-C\-~\-M\-o\-r\-p\-h\-o\-l\-o\-g\-y\-~\-T\-o\-o\-l\-b\-o\-x\-~\-V\-0\-.\-8\-.\-1\-~\-0\-1\-F\-e\-b\-0\-5\-~\-(\-n\-u\-m\-a\-r\-r\-a\-y\-~\-v\-e\-r\-s\-i\-o\-n\-)\-'\-}            \textit{(type=\texttt{str})}&\\
\cline{1-2}
\raggedright m\-y\-d\-i\-r\- & \raggedright \textbf{Value:} 
{\tt '\-/\-d\-a\-t\-a\-/\-c\-h\-u\-l\-a\-k\-1\-/\-d\-e\-v\-/\-M\-u\-l\-t\-i\-d\-r\-i\-z\-z\-l\-e\-/\-m\-u\-l\-t\-i\-r\-e\-g\-'\-}            \textit{(type=\texttt{str})}&\\
\cline{1-2}
\end{longtable}

    \index{multireg.num\_pymorph \textit{(module)}|)}
