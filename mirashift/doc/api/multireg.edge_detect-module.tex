%
% API Documentation for ImageShift
% Module multireg.edge_detect
%
% Generated by epydoc 2.1
% [Thu Dec 15 12:26:52 2005]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{multireg.edge\_detect \textit{(module)}|(}
\section{Module multireg.edge\_detect}

    \label{multireg:edge_detect}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{multireg:edge_detect:canny_edge}
    \index{multireg.edge\_detect \textit{(module)}!canny\_edge \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{canny\_edge}(\textit{image}, \textit{alpha}=\texttt{0\-.\-1\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-0\-1\-}, \textit{thin}=\texttt{F\-a\-l\-s\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Canny edge detector algorithm implementation.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:compute_edge_strength}
    \index{multireg.edge\_detect \textit{(module)}!compute\_edge\_strength \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{compute\_edge\_strength}(\textit{array}, \textit{zero\_cross})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute the edge strength map for a LoG of an image by considering 
    the slopes along both the x and y directions.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:compute_LoG_image}
    \index{multireg.edge\_detect \textit{(module)}!compute\_LoG\_image \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{compute\_LoG\_image}(\textit{image}, \textit{k\_d}, \textit{k\_sigma}, \textit{gsigma}, \textit{gauss\_sigma})

    \end{boxedminipage}

    \label{multireg:edge_detect:compute_max_neighbor}
    \index{multireg.edge\_detect \textit{(module)}!compute\_max\_neighbor \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{compute\_max\_neighbor}(\textit{array})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute max[N(i,j)*signum(-1*array).

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:dgauss}
    \index{multireg.edge\_detect \textit{(module)}!dgauss \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{dgauss}(\textit{x}, \textit{sigma})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute first order derivative of gaussian function.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:find_edge_points}
    \index{multireg.edge\_detect \textit{(module)}!find\_edge\_points \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{find\_edge\_points}(\textit{array})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Detects the edge points from a LoG image
using the criteria:
- for each zero-crossing pixel, it is an
edge point iff
LoG(i,j) {\textless}= max[N(i,i)*signum(-LoG(i,j))]

where N(i,j) is the 8-neighborhood values for i,j and
      Log(i,j) is the LoG value of the pixel i,j
Ref: Dai \& Khorram (1999), IEEE Trans. GeoSci. and
     Remote Sensing, Vol 37, No 5, 2351-2362.\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:find_index}
    \index{multireg.edge\_detect \textit{(module)}!find\_index \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{find\_index}(\textit{array}, \textit{values})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Return the index into array that corresponds to each value.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:find_LoG_zeros}
    \index{multireg.edge\_detect \textit{(module)}!find\_LoG\_zeros \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{find\_LoG\_zeros}(\textit{image}, \textit{esigma}=\texttt{3\-})

    \end{boxedminipage}

    \label{multireg:edge_detect:gauss}
    \index{multireg.edge\_detect \textit{(module)}!gauss \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{gauss}(\textit{x}, \textit{sigma})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute gaussian.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:gauss_edge_kernel}
    \index{multireg.edge\_detect \textit{(module)}!gauss\_edge\_kernel \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{gauss\_edge\_kernel}(\textit{nx}, \textit{ny}, \textit{sigma\_x}, \textit{sigma\_y}, \textit{theta})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Computes the 2D edge detector (first order derivative of 2D Gaussian 
    function) with size n1*n2. Theta is the angle the detector rotated 
    counter clockwise, while sigma\_x and sigma\_y are the stddev of the 
    Gaussian functions.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:gauss_kernel}
    \index{multireg.edge\_detect \textit{(module)}!gauss\_kernel \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{gauss\_kernel}(\textit{nx}, \textit{ny}=\texttt{N\-o\-n\-e\-}, \textit{sigma\_x}=\texttt{1\-.\-0\-}, \textit{sigma\_y}=\texttt{N\-o\-n\-e\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Computes the 2D Gaussian with size n1*n2. Sigma\_x and sigma\_y are 
    the stddev of the Gaussian functions. The kernel will be normalized 
    to a sum of 1.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:interp2}
    \index{multireg.edge\_detect \textit{(module)}!interp2 \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{interp2}(\textit{xk}, \textit{yk}, \textit{zk}, \textit{xint}, \textit{yint})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute the 2D interpolated value.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:interp_bilinear1d}
    \index{multireg.edge\_detect \textit{(module)}!interp\_bilinear1d \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{interp\_bilinear1d}(\textit{x}, \textit{xi})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Compute the bilinear interpolated value(s) of xi within x.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:LoG_mask}
    \index{multireg.edge\_detect \textit{(module)}!LoG\_mask \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{LoG\_mask}(\textit{sigma}=\texttt{1\-.\-0\-}, \textit{cutoff}=\texttt{3\-.\-8\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-9\-}, \textit{peak}=\texttt{1\-.\-0\-})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Returns a Laplacian-of-Gaussian kernel [Ref. 1] with a mean of 0 and 
    a peak specified by the user. If no width is provided by the user, 
    the size of the kernel will be automatically determined based on 
    C\_log/sigma = 3.9 to include 99.83\% of the energy. References: 
    (1)Chen, et al, IEEE PAMI, PAMI-9, No. 4, July 1987, pg 584-590.

    \vspace{1ex}

    \end{boxedminipage}

    \label{multireg:edge_detect:signum}
    \index{multireg.edge\_detect \textit{(module)}!signum \textit{(function)}}
    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{signum}(\textit{array})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\begin{alltt}
Return the signum values for the input array,
where the signum has the standard definition:
    signum(x = array(i,j)) = -1 for x {\textless} 0

                              0 for x == 0
                              1 for x {\textgreater} 0\end{alltt}

    \vspace{1ex}

    \end{boxedminipage}

    \index{multireg.edge\_detect \textit{(module)}|)}
