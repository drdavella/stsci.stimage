################################################################
#
# Create and display an RGB image
#
################################################################
oimg0 = pyfits.open('j93k52c1q_noshift_sci.fits')
oimg1 = pyfits.open('j93k53jaq_noshift_sci.fits')
orgbs = N.zeros((500,400,3),N.UInt8)
orgbs[:,:,0] = numdisplay.bscaleImage(oimg0['sci',1].data[2500:3000,400:800],iz2=0.65,iz1=-0.1,pmax=255)
orgbs[:,:,1] = numdisplay.bscaleImage(oimg1['sci',1].data[2500:3000,400:800],iz2=0.65,iz1=-0.1,pmax=255)
orgbs[:,:,2] = numdisplay.bscaleImage(oimg1['sci',1].data[2500:3000,400:800],iz2=0.65,iz1=-0.1,pmax=255)
pl.imshow(orgbs)


################################################################
#
# Testing ImageShifts and ImageMatch as a whole
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
reset stdimage = imt8192
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
import mirashift
import imagestats
import numdisplay 
import pyfits
import pylab as pl
time
#w = mirashift.ImageShift('test_orion_asn.fits',median=2)
w = mirashift.ImageShift('tweak_match_asn.fits',median=2)
time
w.run()
time

################################################################
#
# Testing ImageShifts and ImageMatch functions individually
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
reset stdimage = imt8192
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
import mirashift
from mirashift import chipwavelets,objectlist
import expandArray
import imagestats
import numdisplay 
import pyfits
import chainMoments
from math import sqrt,pow
time
w = mirashift.ImageShift('test_orion_asn.fits',median=2)
scale = w.scale
wimg = w.obslist[1]
time
moment_matrix,ccode_matrix,image_cog,ref_cog = chipwavelets._step2(w.obslist[1],w.refobs,scale)
time
obs1mom = N.array(w.obslist[1].getMoments(scale=2))
refmom = N.array(w.obslist[0].getMoments(scale=2))

refobj = w.obslist[0].chiplist[1].objectlist.getObjects(scale=2)
imgobj = w.obslist[1].chiplist[0].objectlist.getObjects(scale=2)

#for img in w.obslist:
#if wimg.name == w.refimage:
#  continue
#gcp_match,final_fit = chipwavelets.perform_ImageMatch(wimg,w.refobs,scale,T_ccode=Tccode,T_moment=Tmoment)

ref_ccode,ref_clen = w.obslist[0].getChainCodes(scale=2)
img_ccode,img_clen = w.obslist[1].getChainCodes(scale=2)
icode = img_ccode[2]
rcode = ref_ccode[1]
chainMoments.computeChainMatch(icode,rcode,3, 0, objectlist.Chain_kernel)

Tccode = 0.8
Tmoment = 0.2
chipwavelets._step3(moment_matrix,ccode_matrix,Tmoment,Tccode)

#psi_matrix,min_elems = chipwavelets._step4(moment_matrix,ccode_matrix)
psi_matrix,min_elems = chipwavelets._step4(moment_matrix,ccode_matrix,image_cog,ref_cog)

print 'min_elems input to _step5: '
#print min_elems
initial_fit = chipwavelets._step5(image_cog,ref_cog,min_elems)
print 'Initial fit from _step5: '
print initial_fit
    
# RMSE error limit in pixels
E_r = None
gcp_match = chipwavelets._step6(initial_fit,image_cog,ref_cog,E_r)
print 'For ',wimg.name,':',final_fit 


################################################################
#
# building Shape matrix
#
################################################################
import numarray as N
from math import sqrt,pow
rad_matrix = psi_matrix.copy()
rad_matrix[N.where(rad_matrix == rad_matrix.max())] = -1.0
i = 0
for ipos in image_cog:
  j = 0
  for rpos in ref_cog:
    if (rad_matrix[i][j] > 0):
        rot = (N.arctan2(ipos[1]-rpos[1],ipos[0]-rpos[1]) * 180./N.pi) % 360.
        #rad_matrix[i][j] = sqrt(pow((ipos[0]-rpos[0])*N.cos(rot),2)+pow((ipos[1]-rpos[1])*N.sin(rot),2))
        rad_matrix[i][j] = sqrt(pow((ipos[0]-rpos[0]),2)+pow((ipos[1]-rpos[1]),2))
    j += 1
  i += 1
radhist = imagestats.histogram1d(rad_matrix.flat,int(rad_matrix.max()/2.0)+1,2.0,-1.)
rad_peak = radhist.centers[N.where(radhist.histogram == radhist.histogram.max())[0]][0]
rad_matrix[N.where(abs(rad_matrix - rad_peak) > 4.0)] = -1.0 
#
# if max_rot at 0 or 360., check for secondary peaks.  
#    Method yet to be determined...
#
rot_mode = rothist.centers[N.where(rothist.histogram == rothist.histogram[30:-30].max())[0][0]]


################################################################
#
# Testing chain-code matching algorithm manually
#
################################################################

sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
import mirashift
from mirashift import chipwavelets,objectlist
import expandArray
import imagestats
import numdisplay 
import pyfits
import chainMoments
rcode = N.array([-3.31578946, -3.31578946, -3.21578956, -3.11578941, -2.91578937,
       -3.01578951, -2.91578937, -2.61578941, -2.4157896 , -2.21578932,
       -2.11578941, -1.81578946, -1.81578946, -1.51578951, -1.41578948,
       -1.31578946, -1.21578956, -1.11578941, -0.91578937, -1.01578951,
       -1.01578951, -0.81578946, -0.81578946, -0.41578937, -0.21578956,
        0.18421054,  0.18421054,  0.48421049,  0.58421063,  0.68421054,
        0.68421054,  0.78421044,  0.98421073,  1.28421044,  1.38421035,
        1.28421044,  1.58421063,  1.78421044,  2.08421063,  1.98421073,
        2.08421063,  2.38421035,  2.48421073,  2.48421073,  2.38421035,
        2.68421054,  2.98421073,  2.98421073,  2.98421073,  3.18421054,
        2.48421073,  2.08421063,  0.08421063,  0.18421054, -1.21578956,
       -0.51578951,  0.88421035], type=N.Float32)
icode2 = N.array([-3.79999995, -3.70000005, -3.5       , -3.        , -2.69999981,
       -2.19999981, -2.0999999 , -1.5       , -1.39999986, -1.0999999 ,
       -1.0999999 , -1.20000005, -1.0999999 , -1.0999999 , -1.20000005,
       -1.0999999 , -1.0999999 , -1.20000005, -1.0999999 , -1.0999999 ,
       -1.20000005, -0.89999986, -0.70000005, -0.29999995, -0.29999995,
        0.10000014,  0.29999995,  0.60000014,  0.50000024,  0.50000024,
        0.70000005,  0.79999995,  1.20000005,  1.60000014,  1.70000005,
        2.00000024,  2.20000005,  2.39999986,  2.70000005,  2.70000005,
        3.00000024,  3.10000014,  2.50000024,  1.79999995,  0.39999986,
        1.10000014,  1.10000014,  0.39999986,  1.10000014,  1.10000014,
       -0.29999995,  0.39999986, -0.29999995,  1.79999995,  2.50000024], type=N.Float32)
chainMoments.computeChainMatch(icode2,rcode,3, 0, objectlist.Chain_kernel)
icode = N.array([-3.48421049, -3.48421049, -3.38421059, -3.0842104 , -2.48421049,
       -1.88421047, -1.58421052, -1.48421049, -1.48421049, -1.48421049,
       -1.48421049, -1.48421049, -1.48421049, -1.48421049, -1.48421049,
       -1.48421049, -1.48421049, -1.48421049, -1.48421049, -1.48421049,
       -1.58421052, -1.68421054, -1.88421047, -1.78421044, -1.78421044,
       -1.88421047, -1.78421044, -1.88421047, -2.18421054, -2.28421044,
       -2.28421044, -2.18421054, -2.48421049, -2.78421044, -2.68421054,
       -2.5842104 , -2.38421059, -2.18421054, -1.88421047, -1.78421044,
       -1.88421047, -1.58421052, -1.38421059, -0.88421059, -0.78421044,
       -0.28421044, -0.28421044,  0.01578951,  0.4157896 ,  0.8157897 ,
        0.8157897 ,  0.9157896 ,  1.21578932,  1.4157896 ,  1.51578951,
        1.51578951,  1.61578941,  1.71578932,  1.9157896 ,  1.71578932,
        1.61578941,  1.61578941,  1.71578932,  1.9157896 ,  1.8157897 ,
        1.8157897 ,  2.01578951,  1.9157896 ,  2.11578941,  2.01578951,
        2.21578932,  2.21578932,  2.11578941,  2.3157897 ,  2.3157897 ,
        2.3157897 ,  2.11578941,  2.3157897 ,  2.4157896 ,  2.4157896 ,
        2.3157897 ,  2.11578941,  2.4157896 ,  2.61578941,  2.9157896 ,
        2.71578932,  2.71578932,  2.8157897 ,  3.21578932,  2.71578932,
        2.11578941,  0.01578951,  0.71578932,  0.01578951,  1.4157896 ], type=N.Float32)
rs = expandArray.resample1DF32(rcode,(1.*len(icode2)/len(rcode)),3,0)
chainMoments.computeChainMatch(icode,rcode,3, 0, objectlist.Chain_kernel)

################################################################
#
# Testing Chip/Observation classes 
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
from pydrizzle import fileutil
import mirashift
from mirashift import chipwavelets
import numdisplay 
reset stdimage = imt8192
import chainMoments
#
p = pydrizzle.PyDrizzle('test_orion_asn.fits',kernel='turbo',bits_single=None,bits_final=None)
obslist = []
obs = None
for pdict in p.parlist:
    chip = chipwavelets.Chip(pdict['exposure'])
    obsname,obsext = fileutil.parseFilename(pdict['data']) 
    if obs == None:
        obs = chipwavelets.Observation(obsname)       
    elif obsname != obs.name:
        obslist.append(obs)
        del obs
        obs = chipwavelets.Observation(obsname)
    obs.addChip(chip)
    del chip
#    
obslist.append(obs)
refobs = chipwavelets.ReferenceObs(p.observation.product.getWCS())
refobs.addChip(obslist[0])
refobs.checkOverlap(obslist[1])
# Perform matching between refobs and next chip, if they overlap
m1 = obslist[0].getMoments(2)
m2 = obslist[1].getMoments(2)
mat = chainMoments.getMomentMatrix(m1,m2)
# Now, we need to build the chain-code matching matrix...


################################################################
#
# Extracting edges of extended sources using L-of-G method  
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
import mirashift
from mirashift import atrous,edge_detect,morph,objectlist,linearfit
import expandArray
import imagestats
import numdisplay 
reset stdimage = imt8192
import pyfits
import chainMoments
#
p = pydrizzle.PyDrizzle('test_orion_asn.fits',kernel='turbo',bits_single=None,bits_final=None)
pyexp1 = p.parlist[1]['exposure']
chip1 = pyexp1.runDriz()
scale = 3
offset = [pyexp1.xzero,pyexp1.yzero]
# This step takes the bulk of the time...
wplanes,wchip,max_kernel = atrous.multimed(chip1,maxscale=scale,median=1)
del wplanes
#############
# Edge detection using fast Lagrangian-of-Gaussian
#    as described in Chen et al(1987).
### AND  ### 
# Find zero-crossings: actually, find the contours corresponding
#    to mean+stddev level (for the minimum).
#############
edges = edge_detect.find_LoG_zeros(wchip)
wlabels,nobjs = ND.label(edges,structure=ND.generate_binary_structure(2,2))
wobjs = ND.find_objects(wlabels)
cont1 = edges[wobjs[176]].copy()
# extract chain code for this region
npix = len(N.nonzero(cont1)[0])
ccode = chainMoments.getChainCode(cont1,npix)
Chain_kernel = [0.1,0.2,0.4,0.2,0.1]
gcode = ND.convolve(ccode.astype(N.Float32),Chain_kernel)
gcode -= N.average(gcode)
del wobjs,wlabels,nobjs
chip2 = p.parlist[2]['exposure'].runDriz()
wplanes2,wchip2,max_kernel = atrous.multimed(chip2,maxscale=scale,median=1)
del wplanes2
edges2 = edge_detect.find_LoG_zeros(wchip2)
wlabels2,nobjs2 = ND.label(edges2,structure=ND.generate_binary_structure(2,2))
wobjs2 = ND.find_objects(wlabels2)
del wlabels2
cont2 = edges2[wobjs2[198]].copy()
npix2 = len(N.nonzero(cont2)[0])
ccode2 = chainMoments.getChainCode(cont2,npix2)
gcode2 = ND.convolve(ccode2.astype(N.Float32),Chain_kernel)
gcode2 -= N.average(gcode2)
# Resample to same length
# The convolution needs to be done to smooth out
# pixel-to-pixel jumps introduced by the resampling.
#
gcode2s = ND.convolve(expandarray.resample1DF32(gcode2,0,3,len(gcode)),Chain_kernel)
# 'gcode' and 'gcode2s' are now ready for matching.
#
##########
#
S_ij = chainMoments.computeChainMatch(gcode,gcode2s)
if (S_ij < 0.65) S_ij = 0.0

#
# Prepare extracted region for moment analysis
#
fedges = ND.binary_fill_holes(cont1)
mimg = N.multiply(wchip[wobjs[176]].copy(),fedges)
numdisplay.display(mimg,frame=2)



################################################################
#
# Extracting edges of extended sources using L-of-G method  
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
import mirashift
from mirashift import atrous,edge_detect,morph
import expandArray
import imagestats
import numdisplay 
reset stdimage = imt8192
import pyfits
import chainMoments
#
p = pydrizzle.PyDrizzle('test_orion_asn.fits',kernel='turbo',bits_single=None,bits_final=None)
pyexp1 = p.parlist[1]['exposure']
chip1 = pyexp1.runDriz()
scale = 2
offset = [pyexp1.xzero,pyexp1.yzero]
# This step takes the bulk of the time...
wplanes,wchip,max_kernel = atrous.multimed(chip1,maxscale=scale,median=2)
del wplanes
#############
# Edge detection using fast Lagrangian-of-Gaussian
#    as described in Chen et al(1987).
### AND  ### 
# Find zero-crossings: actually, find the contours corresponding
#    to mean+stddev level (for the minimum).
#############
lgedge = edge_detect.find_LoG_zeros(wchip)
##
# At this point, we have the contours of the zero-crossing 
#    edges.  
##
#
# Label detected objects
#
wlabels,nobjs = ND.label(lgedge,structure=ND.generate_binary_structure(2,2))
# Extract slices for each object 
wobjs = ND.find_objects(wlabels)
# 
# Compute modified chain-code for each contour
#
# get pixels in contour
chain_codes = [] 
skernel = [0.1,0.2,0.4,0.2,0.1]
for c in range(nobjs):
    cpix = wlabels[wobjs[c]] == c+1
    npix = len(N.nonzero(cpix)[0])
    ccode = chainMoments.getChainCode(cpix,npix)
    gcode = ND.convolve(ccode,skernel)
    # compute and subtract the mean from the chain-code
    gcode -= N.average(gcode)
    chain_codes.append(gcode)
    
del ccode,gcode,cpix
# 
# We now have shifted/smoothed chain codes 
# for all contours
#
#
# Computation of invariant moments
#

cimg = pyfits.open('contour1_edge.fits')
cenxy = ND.center_of_mass(cimg[0].data)
#
# For each contour/object, compute the 7 invariant moments
#
yp,xp = N.nonzero(cimg[0].data)
# subtract the mean x,y positions from the raw x,y positions
yp -= cenxy[0]
xp -= cenxy[1] 
#
# Pre-compute necessary central moments needed 
#     for computing the 7 invariant moments
#
mu00 = chainMoments.getMoment_pq(xp,yp,0,0)
mu11 = chainMoments.getMoment_pq(xp,yp,1,1)
mu12 = chainMoments.getMoment_pq(xp,yp,1,2)
mu20 = chainMoments.getMoment_pq(xp,yp,2,0)
mu02 = chainMoments.getMoment_pq(xp,yp,0,2)
mu21 = chainMoments.getMoment_pq(xp,yp,2,1)
mu30 = chainMoments.getMoment_pq(xp,yp,3,0)
mu03 = chainMoments.getMoment_pq(xp,yp,0,3)
# Now compute invariant moments
psi1 = (mu20 + mu02) / (mu00*mu00)
psi2 = ( pow((mu20 - mu02),2) + 4*pow(mu11,2) ) / pow(mu00,4)
psi3 = ( pow((mu30 - 3*mu12),2) + pow((3*mu21 - mu03),2)) / pow(mu00,5)
psi4 = ( pow((mu30 + mu12),2) + pow((mu21 + mu03),2) ) / pow(mu00,5)
psi5 = ( (mu30 - 3*mu12)*(mu30 + mu12)* 
         (pow((mu30 + mu12),2) - 3*pow((mu21+mu03),2)) -
         (3*mu21 - mu03) * (mu21 + mu03)* 
         (pow((mu21 + mu03),2) - 3*(pow((mu30 + mu12),2)))
        ) / pow(mu00,10)
psi6 = ( (mu20 - mu02)* (pow((mu30+mu12),2) - pow((mu21+mu03),2)) -
         4*(mu30+mu12) * (mu21+mu03)
        ) / pow(mu00,7)
psi7 = (  (3*mu21 - mu03)*(mu30+mu12) *
        ( pow((mu30 +mu12),2) - 3*pow((mu21+mu03),2)) -
        (mu30 - mu12) * (mu21+mu03) * 
        (3*pow((mu30 + mu12),2) - pow((mu21+mu03),2))
        ) / pow(mu00,10)
psi = []
psi.append(psi1)
psi.append(psi2)
psi.append(psi3)
psi.append(psi4)
psi.append(psi5)
psi.append(psi6)
psi.append(psi7)

# For each object in image i and each object in image j
# compute the invariant-moment distance matrix using:
d_ij = N.sqrt(N.sum(N.power((psi_i - psi_j),2)))



################################################################
#
# Simple Laplacian of Gaussian contour extraction 
#
################################################################
reset stsdas = '/data/chulak1/dev/stsdas/'
stsdas
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import pydrizzle
import numarray as N
from numarray import nd_image as ND
from mirashift import edge_detect
import expandArray
p = pydrizzle.PyDrizzle('test_orion_asn.fits',kernel='turbo',bits_single=None,bits_final=None)
pyexp1 = p.parlist[1]['exposure']
chip1 = pyexp1.runDriz()

# nx = int(ceil(N.pi * gauss_sigma)) = 13 
# ksig = 1.25 for gauss_sigma=4.0
# sigma_x = sqrt(1 - (1/ksig**2))*gauss_sigma
# k_d < gauss_sigma*N.pi / (sqrt(C_log**2 + C_gauss**2))
#    k_d = 3 for gauss_sigma=4.0
k_d = 3
gauss_sigma = 4.0
k_sigma = 1.25
gk = edge_detect.gauss_kernel(13,sigma_x=2.4)
logk = edge_detect.LoG_mask( (gauss_sigma/(k_d*k_sigma)) )
gchip = ND.convolve(chip1[::k_d,::k_d],gk)
lgchip = ND.convolve(gchip,logk)
logchip = expandArray.expandArrayF32(lgchip,k_d,1)



###########################
#
# Photometry of detected regions
#
###########################
# Remove border detections from object list and image
# Also, delete any object which is smaller than smoothing kernel size.
# Slow way of doing this...
for obj in xrange(nobjs):
    reg = wobjs[obj]
    reg_xsize = reg[1].stop - reg[1].start
    reg_ysize = reg[0].stop - reg[0].start
    if (reg_ysize == wlabels.shape[0] and reg_xsize == wlabels.shape[1]):
        wlabels = N.where(wlabels == int(obj)+1, 0, wlabels)
        wobjs[obj] = None
        break
# Trim source detections to only those comparable in size to the kernel
# Also, delete any object which is smaller than smoothing kernel size.
nobj_final = nobjs
for obj in xrange(nobjs):
  if wobjs[obj] != None:
    reg = wobjs[obj]
    reg_xsize = reg[1].stop - reg[1].start
    reg_ysize = reg[0].stop - reg[0].start

    if (size != None and (reg_xsize < size[0] and reg_ysize < size[1])) or \
        (reg_xsize <= 1  or reg_ysize <= 1):
         wlabels[wobjs[obj]] = 0
         wobjs[obj] = None
         nobj_final -= 1
#
# 
photzpt = -21.1
photflam = 1.955927e-19
#photzpt = pyexp1.header['photzpt']
#photflam = pyexp1.header['photflam']
thin = False
#
# Warning: This does not go quickly!
#
slist = []
for i in xrange(len(wobjs)):
    if wobjs[i] != None:
        stype = findobjects.discriminate_source(wchip[wobjs[i]],wlabels[wobjs[i]],i+1)
        xzero = wobjs[i][1].start+offset[0]
        yzero = wobjs[i][0].start+offset[1]
        if stype == 1:
            # We have a point source...
            # Start by finding the pixel with maximum value
            maxpos = ND.maximum_position(wchip[wobjs[i]],wlabels[wobjs[i]],i+1)
            maxpos = [maxpos[0]+wobjs[i][0].start+1,maxpos[1]+wobjs[i][1].start+1]
            # Cut out slice centered on max value pixel
            pslice = wchip[maxpos[0]-11:maxpos[0]+12,maxpos[1]-11:maxpos[1]+12].copy()
            plabel = wlabels[maxpos[0]-11:maxpos[0]+12,maxpos[1]-11:maxpos[1]+12].copy()
            # Mask with label mask
            pslice = N.where(plabel == i+1, pslice, 0)
            # Now find center using 'imcntr' algorithm
            cenmass = findobjects.find_center(pslice)
            # Shift position to final output frame position
            cenpos = [cenmass[1]+maxpos[1]-10+offset[0], cenmass[0]+maxpos[0]-10+offset[1]]
            # Compute photometry for source now
            wmag = photzpt - 2.5 * N.log10(photflam*ND.sum(wchip,wlabels,i+1))
            # Add source information to target list
            slist.append([i+1,[cenpos],wmag])  
            del pslice,plabel
        else:        
            #
            #  extract edges using...
            #
            wmag = photzpt - 2.5 * N.log10(photflam*ND.mean(wchip,wlabels,i+1))
            if not thin:
                edge_clwchip = ND.binary_dilation(gclip[wobjs[i]]) - gclip[wobjs[i]]
            else:
                edge_clwchip = NP.mmthin(gclip[wobjs[i]].astype(N.Bool))
                edge_clwchip = NP.mmthin(edge_clwchip,NP.mmendpoints(),4)
            nzero_y,nzero_x = N.nonzero(edge_clwchip)            
            elist = []
            for p in xrange(len(nzero_x)):
                elist.append([nzero_x[p]+xzero,nzero_y[p]+yzero])
            slist.append([i+1,elist,wmag])
            del elist

################################################################
#
# testing expandArray
#
################################################################
sys.path.insert(1,'/data/chulak1/dev/Multidrizzle')
import numarray as N
import expandArray
a = N.arange(32*64,shape=(32,64))+1
b = a[::4,::4].copy()
c = expandArray.expandArrayF32(b,4,1)
print a
array([[ 1,  5, 10],
       [ 5, 25, 50]])



################################################################
#
# Testing object identification algorithm in findobjects
#
################################################################
p = pydrizzle.PyDrizzle('test_orion_asn.fits',kernel='turbo',bits_single=None,bits_final=None)
pyexp1 = p.parlist[1]['exposure']
chip1 = pyexp1.runDriz()
scale = 2
offset = [pyexp1.xzero,pyexp1.yzero]
wplanes,wchip = atrous.multimed(chip1,maxscale=scale,median=2)
esigma = 1.0
wcstats = imagestats.ImageStats(wchip,nclip=3,fields='stddev,mean')
eclip = wcstats.mean + esigma*wcstats.stddev

opos,oslice,olabels = findobjects.get_positions(wchip,lower=eclip,offset=offset,scale=scale)
# Initialize ObjectList
objlist = objectlist.ObjectList(scale=scale+1)
objlist.addObjects(scale,None,positions=opos,slices=oslice)
for s in xrange(scale-1,-1,-1):
    sc = atrous.atrous_restore(wplanes,wchip,scale=s)
    sobj = objlist.getObjects(scale=s+1)
    for obj in sobj:    
        srange = (obj.region[0].stop - obj.region[0].start,
                  obj.region[1].stop - obj.region[1].start)
        if min(srange) >= ((2**s) * 2)+1:
            spos,sslice,slabel = findobjects.get_positions(sc,lower=eclip,region=obj.region,offset=offset,scale=s+1)
        

################################################################
#
# Computing an L-of-G kernel with arbitrary sigma  
# 
#   D2_H(r) = -((r**2 - sigma**2)/sigma**4)*exp(-r**2/(2*sigma**2))
#   
#   where
#     r**2 = x**2 + y**2
#     sigma = standard deviation 
# 
#
#    where the size of the mask used follows C_log / sigma = 3.9 
#    to include 99.83% of energy.                
#    Sample LoG kernel from: 
#    www.ic.sunysb.edu/Stu/abracovi/ESE441FinalPaper.doc
#                 0 0 -1 0 0
#
#                0 -1 -2 -1 0
#
#                -1 -2 16 -2 -1
#
#                0 -1 -2 -1 0
#
#                 0 0 -1 0 0 
#
#    
################################################################
def get_log_kernel(sigma=1.0):
  from math import ceil
  #kwidth = int((2 * 5 * ceil(sigma)) + 1)
  kwidth = ceil(3.9 * sigma)
  if (kwidth%2) == 0: kwidth += 1
  cen = int(kwidth/2) + 1
  lk = N.zeros([kwidth,kwidth],N.Float32)
  for y in xrange(kwidth):
    for x in xrange(kwidth):
        xc = (x+1) - cen
        yc = (y+1) - cen 
        r = (xc*xc + yc*yc)
        lk[y,x] = -((pow(r,2)- pow(sigma,2))/(pow(sigma,4)))*N.exp(-pow(r,2)/(2*pow(sigma,2))) 
  
  ilk = N.multiply(lk,lk.nelements()).astype(N.Int16)
  # Scale kernel to mean of 0 and all integer values
  if ilk.sum() == 0.:
    k = 1
  else:
    k = 1/ilk.sum()
  print k,ilk.sum()
  N.multiply(lk,k,lk)
  print lk.sum()
  # Integerize the kernel
  N.subtract(1,lk,lk)
  return lk

################################################################
#
# Discriminating between sources and edges  
#
################################################################
# start by getting global statistics
wstats = imagestats.ImageStats(wchip)
# Find max position, build up sums of concentric radii
# If extra radii adds more than stddev/pixel to the sum, then 
# it should be a positive source, rather than an edge.
#
# Keep track of how a source gets characterized using:
#   wsource = [(i,[0 or 1]),...]
#      where i is the label ID for the mask/object
#            1 for source and 0 for edge
#
wsource = []
#
# 
for i in xrange(len(wobjs)):
    if wobjs[i] != None:
        wsource.append((i,findobjects.discriminate_source(wchip[wobjs[i]],wlabels[wobjs[i]],i+1)))
            
################################################################
#
# Technique for cleaning input images of obvious cosmic-rays
# Output will only be suitable for input to wavelet algorithm for
# source detection
#
################################################################
#
# This technique does affect the cores of stars...
#
fori = pyfits.open(image)
# Detect edges of cosmic-rays using laplace edge-detection
ND.laplace(fori[4].data,output=hik_chip1)

# Fill in the laplace detected regions with black_tophat algorithm
hik_tophat3x3 = ND.black_tophat(hik_chip1,size=[3,3],footprint=[[0,1,0],[1,0,1],[0,1,0]])
hik_tophat3x3_stats = imagestats.ImageStats(hik_tophat3x3)
thresh = hik_tophat3x3_stats.mean + hik_tophat3x3_stats.stddev

# Create a mask based on threshhold from black_tophat product
hik_med3_mask = ND.boxcar(N.clip(hik_tophat3x3 > thresh,1,0),size=[3,3])
# Multiply mask by original image to get masked input
hik_med3 = N.multiply(fori[4].data,hik_med3_mask)
# Smooth out masked input with large boxcar filter to fill in holes
# left by masked out pixels
hik_med3_box = ND.boxcar_filter(hik_med3,size=[31,31])
# Create final cleaned image by replacing masked pixels with 
# smoothed values in a copy of the original image
hik_med3_clean = N.where(hik_med3_mask == 0,hik_med3_box,fori[4].data)
# Close original input image
fori.close()


chip1 = chipwavelets.Chip("j93k52c1q_flt.fits['sci',2]",hik_med3_clean)



====================================
=
=
=  Using qderiv to extract edge pixels for extended sources
=
=
====================================
--> chip1.stats = imagestats.ImageStats(chip1.wavechip,nclip=3,fields='mode,stddev')
--> chip1.stats.printStats()
--- Imagestats Results ---
Standard Deviation:   379.935974121
Mode              :   149.035150125
#
# Generate a threshold mask based on Mode+1.0*STDDEV
#
--> mchip1 = N.clip(chip1.wavechip > 529., 1, 0)
# 
# Create derivative image from mask
# 
--> mchip1 = quickDeriv.qderiv(mchip1)
#
# 'edgepos' is the X and Y arrays for all pixels detected along the 
# edge, with a tracing width of 2 pixels.  We need to extract 
# from [2:-2,2:-2] to avoid edge of chip affects.
#
--> edgepos = N.where(mchip1[2:-2,2:-2] > 0)
 
 
====================================================
=
= Removal of CRs in single exposures
=  Use as precor technique on input to 
=  wavelet transformations?
=
=  This does have the effect of slightly smoothing
=  the final image, unless this is used as a basis for
=  building a mask that can be applied to the original image.
=  This mask does cover the cores of stars as well, but 
=  does a great job of picking up on CRs as well.
=
= 
====================================================
# A size of (3,3) still left some residuals for ACS data
import imagestats
import pyfits
from numarray import nd_image as ND
chip = pyfits.getdata('j93k52c1q_flt.fits','sci',1)
closechip = ND.grey_closing(rchip,size=(5,5))
occhip = ND.grey_opening(closechip,size=(5,5))
chipstats = imagestats.ImageStats(occhip,nclip=3)
sigma = chipstats.stddev
mask = numarray.where(chip - occhip > sigma,1,0)


====================================================
=
=  Create a mask of only those objects which have values
=  greater than the mean of the background.  
=  Measurements can then be done on only those masked objects.
=
====================================================
import pyfits
import imagestats
sci = pyfits.getdata('j8bt06nyq_flt.fits','sci',1)
#
# compute background value, clipping out bright sources
scistats = imagestats.ImageStats(sci,nclip=3) 
#
# create a binary image flagging all sources in image
# with values greater than the mean of the background
# For crowded fields, extra care/work will need to be 
# done to separate blended sources.
sci_clip = N.where(sci >= scistats.mean, 1, 0)
#
# label each source with its own ID index
sci_labels,sci_num = ND.label(sci_clip)
#
# Compute a sum for each object labeled and return as a list
counts = ND.sum(sci,sci_labels,range(sci_num)) 
#
# Get position of object using its center of mass
pos = ND.center_of_mass(sci,sci_labels,range(sci_num))
#
# Retrieve photometric keywords from image header
photflam = pyfits.getval('j8bt06nyq_flt.fits','photflam','sci',1)
photzpt = pyfits.getval('j8bt06nyq_flt.fits','photzpt','sci',1)
#
# Convert counts to magnitudes for each object
mag = photzpt - 2.5*numarray.log10(N.array(counts)*photflam)

====================================================
=
=  Create a mask of only those objects which remain at least
=  1 sigma above the mode when comparing the scale=0 and 
=  scale=1/median-filtered images.
=
=  This mask leaves only the strongest sources behind,
=  including stars, extended sources, but removes a majority
=  of the cosmic-rays.
= 
====================================================

--> imagestats.ImageStats(rchip,nclip=3,fields='mode,stddev,mean').printStats()
--- Imagestats Results ---
Standard Deviation:   381.159362793
Mean              :   526.924072266
Mode              :   136.087519912
--> imagestats.ImageStats(rchip2,nclip=3,fields='mode,stddev,mean').printStats()
--- Imagestats Results ---
Standard Deviation:   379.736633301
Mean              :   525.830566406
Mode              :   146.775772372
--> tchip1 = N.greater(rchip, 136.087519912+526.924072266)
--> tchip2 = N.greater(rchip2, 146.775772372+525.830566406)
--> orchip = N.bitwise_and(tchip1,tchip2)

====================================================
=
= How to identify features in an image using 
=  the watershed algorithm with markers.
= 
====================================================
fori = pyfits.open(image)
chip1 = chipwavelets.Chip("j93k52c1q_flt.fits['sci',2]",fori["sci",2].data)
fori.close()
rchip2 = wavelets.atrous.atrous_restore(chip1.waveplanes,chip1.wavechip,scale=1)
kernelsz = (3,3)  
gchip = ND.morphological_gradient(rchip2,size=kernelsz).astype(N.UInt16)
gchipws = ND.maximum_filter(gchip,size=kernelsz) - gchip
gstats = imagestats.ImageStats(gchipws,nclip=3,fields='mode,stddev,min,max')
stddev = gstats.mode + 3.*gstats.stddev
gchipws = N.where(gchipws > stddev, gchip, 0)
gchipws = ND.grey_closing(gchipws,size=kernelsz)
cpk = ND.generate_binary_structure(2,2)
gchipws = ND.watershed_ift(gchip,gchipws,structure=cpk)
#
# At this point, we have an image which maps the bright features
# regardless of morphology (star vs. extended source).
# If we want to make a mask for comparison, clip the image
# at 3*stddev above the mode, label the regions, and use
# 'find_objects' to get the slices.
#
wstats = imagestats.ImageStats(gchipws,nclip=3,fields='mode,stddev,min,max')
wstddev = wstats.mode + 3.*wstats.stddev
gchipws = N.where(gchipws > wstddev, 1, 0)
# Create final mask image
wsobj = ND.label(gchipws)
# extract slices around objects in mask image
wobj = ND.find_objects(wsobj[0])
# 
# Unfortunately, there still may be single pixel features
# picked up here, so they need to be removed before
# the list of objects can be used for fitting...
#
objlist = []
min_size = 3
for w in wobj:
    if (w[0].stop - w[0].start >= min_size) and 
      (w[1].stop - w[0].start >= min_size):
        objlist.append(w)
        
        
################################################################
#
# Creating a CR-mask from a single image
#
################################################################
img1 = pyfits.open('j93k52c1q_flt.fits')
chip1 = img1['sci',2].data

# Create mask of all CR-like features
c1e = ND.grey_erosion(chip1,size=(7,7))
c1or = morph.recon_by_dilation(c1e,chip1)
c1mask = chip1 - c1or
mstats = imagestats.ImageStats(c1mask)
crmask = N.where(c1mask >= mstats.mean+mstats.stddev, 1, 0)

# Create mask of all point-source-like features in 'cleaned' image
# Start by insuring that no negative holes exist and chip-defects
c1med = ND.median_filter(c1or,size=(5,5))
# Smooth out any non-point source objects
c1g = ND.morphological_gradient(c1med,size=(7,7))
# We need to 'close' any point-source holes
c1g = ND.grey_closing(c1g,size=(7,7))
hstats = imagestats.ImageStats(c1g)
thmask = N.where(c1g >= hstats.mean+(10*hstats.stddev), 1, 0)

# Remove any objects detected in 'thmask' from 'smc1clip'
crmask = N.clip(crmask-thmask, 0, 1)


phdu = pyfits.PrimaryHDU(data=crmask)
phdu.writeto('chip1_crmask.fits')

################################################################
#
# Extracting extended source edges 
#
################################################################
img1 = pyfits.open('j93k52c1q_flt.fits')
chip1 = img1['sci',2].data

# Create mask of all CR-like features
c1e = ND.grey_erosion(chip1,size=(7,7))
c1or = morph.recon_by_dilation(c1e,chip1)
# Create mask of all point-source-like features in 'cleaned' image
# Start by insuring that no negative holes exist and chip-defects
c1med = ND.median_filter(c1or,size=(5,5))
#
# Alternatively, we could work with just the
# median-smoothed, wavelet transformed image section
# as the input numarray object.  The section would be
# identified as having a dimension >> wavelet-scale
# as segmented in the normal manner for point sources.
#
# Segment the image gray-scale levels
#  to enhance the gradients along edges of 
#  extended sources
#  This will be done by resampling the values to
#   only 'nlevels' (50) integer grey-scale values.
#
nlevels = 50
c1sets = N.divide(c1med,c1med.max()/nlevels).astype(N.Int8)
# Now, compute the gradient of the image
c1g = ND.morphological_gradient(c1med,size=(3,3))
# The contours can be thinned to 1-pixel wide outlines using:
c1gt = NP.mmthin(N.where(c1g>0,1,0),1,0).astype(N.Bool))nbins = int((wstats.max - wstats.min)/(wstats.stddev*0.1))

# Unfortunately, using 'mmthin' as implemented is VERY SLOW!


################################################################
#
# Implementing UHMT from Soille pg. 144
#
################################################################
--> f = N.array([3, 3, 3, 0, 1, 6, 2, 1, 7, 5, 1, 0, 4, 6, 7, 3, 3, 3], type=Int8)
--> B = N.array([0,0,1,1],N.UInt8)
--> Bc = N.array([1,1,0,0,1,1],N.UInt8)
--> N.maximum(ND.grey_erosion(f,footprint=B) - ND.grey_dilation(f,footprint=Bc),0)
array([0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0], type=Int8)

