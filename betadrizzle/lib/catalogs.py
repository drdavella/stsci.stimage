import numpy as np
import ndimage
import stwcs
from stwcs import wcsutil
import imagestats
try:
    import sextractor
except:
    sextractor = None

#import idlphot
import tweakutils

try:
    from matplotlib import pyplot as pl
except:
    pl = None
    
COLNAME_PARS = ['xcol','ycol','fluxcol']
CATALOG_ARGS = ['sharpcol','roundcol','hmin','fwhm','fluxmax','fluxmin','fluxunits','nbright']+COLNAME_PARS

REFCOL_PARS = ['refxcol','refycol','rfluxcol']
REFCAT_ARGS = ['rfluxmax','rfluxmin','rfluxunits','refnbright']+REFCOL_PARS

def generateCatalog(wcs,catalog=None,**kwargs):
    """ Function which determines what type of catalog object needs to be 
        instantiated based on what type of source selection algorithm the user 
        specified.  
        
        Parameters
        ----------
        wcs: obj
            WCS object generated by STWCS or PyWCS
        catalog: str or ndarray
            Filename of existing catalog or ndarray of image for generation of source catalog
        kwargs: dict
            Parameters needed to interpret source catalog from input catalog 
            with `findmode` being required.
        
        Returns
        -------
        catalog: obj
            A Catalog-based class instance for keeping track of WCS and 
            associated source catalog
    """
    if not isinstance(catalog,Catalog):
        if isinstance(catalog,np.ndarray): # if an array is provided as the source
            # Create a new catalog directly from the image
            if kwargs['findmode'] == 'sextractor' and sextractor is not None:
                #catalog = ExtractorCatalog(wcs)
                catalog = ImageCatalog(wcs,catalog,**kwargs)
            else: 
                catalog = ImageCatalog(wcs,catalog,**kwargs)
        else: # a catalog file was provided as the catalog source
            catalog = UserCatalog(wcs,catalog,**kwargs)
    return catalog

class Catalog(object):
    """ Base class for keeping track of a source catalog for an input WCS

        .. warning:: This class should never be instantiated by itself, 
                     as necessary methods are not defined yet. 
    """
    def __init__(self,wcs,catalog_source,**kwargs):
        """
        This class requires the input of a WCS and a source for the catalog,
        along with any arguments necessary for interpreting the catalog.
        
        
        Parameters
        ----------
        wcs: obj
            Input WCS object generated using STWCS or HSTWCS
        catalog_source: str or ndarray
            Catalog generated from this image(ndarray) or read from this file(str)
        kwargs: dict
            Parameters for interpreting the catalog file or for performing the source
            extraction from the image. These will be set differently depending on 
            the type of catalog being instantiated.
        """
        self.wcs = wcs # could be None in case of user-supplied catalog 
        self.xypos = None
        self.in_units = 'pixels'
        self.sharp = None
        self.round = None
        self.numcols = None
        self.origin = 1 # X,Y coords will ALWAYS be FITS 1-based, not numpy 0-based
        self.pars = kwargs

        self.source = catalog_source
        
        self.radec = None # catalog of sky positions for all sources on this chip/image
        self.set_colnames()
        
    def generateXY(self):
        """ Method to generate source catalog in XY positions
            Implemented by each subclass
        """
        pass

    def set_colnames(self):
        """ Method to define how to interpret a catalog file
            Only needed when provided a source catalog as input
        """
        pass
    
    def _readCatalog(self):
        pass
        
    def generateRaDec(self):
        """ Convert XY positions into sky coordinates using STWCS methods
        """        
        if not isinstance(self.wcs,stwcs.pywcs.WCS):
            print 'WCS not a valid PyWCS object. Conversion of RA/Dec not possible...'
            raise InputError
        
        if self.radec is None or force:
            if self.wcs is not None:
                self.radec = self.wcs.all_pix2sky(self.xypos[0],self.xypos[1],self.origin)
            else:
                # If we have no WCS, simply pass along the XY input positions
                # under the assumption they were already sky positions.
                self.radec = self.xypos

    def buildCatalogs(self):
        """ Primary interface to build catalogs based on user inputs.
        """
        self.generateXY()
        self.generateRaDec()
    
    def plotXYCatalog(self,**kwargs):
        """ Built-in method to accurately display the catalog, overlaid on
            the source image if provided as input
            
            Each sub-class will implement a version specific to it's inputs
        """
        pass
        
    def writeXYCatalog(self,filename):
        """ Write out the X,Y catalog to a file
        """
        if self.xypos is None:
            print 'No X,Y source catalog to write to file. '
            return
        
        f = open(filename,'w')
        f.write("# Source catalog derived for %s\n"%self.wcs.filename)
        f.write("# Columns: \n")
        f.write('#    X      Y         Flux \n')
        f.write('#   (%s)   (%s)\n'%(self.in_units,self.in_units))
        for x,y,flux in zip(self.xypos[0],self.xypos[1],self.xypos[2]):
            f.write("%g  %g    %g\n"%(x,y,flux))
        f.close()
        
        
        
class ImageCatalog(Catalog):
    """ Class which generates a source catalog from an image using
        Python-based, daofind-like algorithms
    
        Required input `kwargs` parameters::
        
            computesig, sigma, threshold, datamin, datamax, 
            hmin, fwhmpsf, [roundlim, sharplim]
            
    """

    def generateXY(self):
        """ Generate source catalog from input image using DAOFIND-style algorithm
        """ 
        #x,y,flux,sharp,round = idlphot.find(array,self.pars['hmin'],self.pars['fwhm'],
        #                    roundlim=self.pars['roundlim'], sharplim=self.pars['sharplim'])
        if self.pars['computesig']:
            # compute sigma for this image
            istats = imagestats.ImageStats(self.source,nclip=3,fields='stddev')
            sigma = 1.5 * istats.stddev
        else:
            sigma = self.pars['sigma']
        hmin = sigma * self.pars['threshold']
        print 'hmin=',hmin,' based on sigma=',sigma,' and threshold = ',self.pars['threshold']
        if self.pars.has_key('datamin') and self.pars['datamin'] is not None:
            source = np.where(self.source <= self.pars['datamin'], 0.,self.source)
        else:
            source = self.source
        if self.pars.has_key('datamin') and self.pars['datamax'] is not None:
            source = np.where(source >= self.pars['datamax'],0.,source)
        
        x,y,flux = tweakutils.ndfind(source,hmin,self.pars['fwhmpsf'])
 
        self.xypos = [x+1,y+1,flux] # convert the positions from numpy 0-based to FITS 1-based
        self.in_units = 'pixels' # Not strictly necessary, but documents units when determined
        self.sharp = None # sharp
        self.round = None # round
        self.numcols = 3  # 5
        
    def plotXYCatalog(self,**kwargs):
        """
        Method which displays the original image and overlays the positions
        of the detected sources from this image's catalog. 
        
        Plotting `kwargs` that can be provided are::
        
            vmin, vmax, cmap, marker

        Default colormap is `summer`.

        """
        if pl is not None: # If the pyplot package could be loaded...
            pl.clf()
            pars = kwargs.copy()

            if pars.has_key('cmap'):
                pl_cmap = pars['cmap']
                del pars['cmap']
            else:
                pl_cmap = 'summer'
            pl_vmin = None
            pl_vmax = None
            if pars.has_key('vmin'):
                pl_vmin = pars['vmin']
                del pars['vmin']
            if pars.has_key('vmax'):
                pl_vmax = pars['vmax']
                del pars['vmax']

            pl.imshow(self.source,cmap=pl_cmap,vmin=pl_vmin,vmax=pl_vmax)
            pl.plot(self.xypos[0]-1,self.xypos[1]-1,pars['marker'])
        
        
class UserCatalog(Catalog):
    """ Class to manage user-supplied catalogs as inputs.

        Required input `kwargs` parameters::

            xyunits, xcol, ycol, fluxcol, [sharpcol, roundcol]
            
    """
    COLNAMES = COLNAME_PARS
    IN_UNITS = None

    def set_colnames(self):
        self.colnames = []
        for cname in self.COLNAMES:
            if cname not in self.pars:
                break
            self.colnames.append(self.pars[cname])
        # count the number of columns
        self.numcols = len(self.colnames)
        
        if self.IN_UNITS is not None:
            self.in_units = self.IN_UNITS
        else:
            self.in_units = self.pars['xyunits']

    def _readCatalog(self):
        # define what columns will be read 
        # The following loops 
        #colnums = [self.pars['xcol']-1,self.pars['ycol']-1,self.pars['fluxcol']-1]

        # read the catalog now, one for each chip/mosaic
        # Currently, this only supports ASCII catalog files
        # Support for FITS tables needs to be added
        catcols = tweakutils.readcols(self.source, cols=self.colnames)        
        return catcols

    def generateXY(self):
        """ 
        Method to interpret input catalog file as columns of positions and fluxes.
        """
        
        xycols = self._readCatalog()
        
        # convert the catalog into attribute
        self.xypos = xycols[:3]
        # convert optional columns if they are present
        if self.numcols > 3:
            self.sharp = xycols[3]
        if self.numcols > 4:
            self.round = xycols[4]

    def plotXYCatalog(self,**kwargs):
        """
        Plots the source catalog positions using matplotlib's `pyplot.plot()` 
        
        Plotting `kwargs` that can also be passed include any keywords understood 
        by matplotlib's `pyplot.plot()` function such as::
        
            vmin, vmax, cmap, marker


        """
        if pl is not None:
            pl.clf()
            pl.plot(self.xypos[0],self.xypos[1],**kwargs)


class RefCatalog(UserCatalog):
    """ Class which manages a reference catalog. 
    
    Notes
    -----
    A *reference catalog* is defined as a catalog of undistorted source positions 
    given in RA/Dec which would be used as the master list for subsequent 
    matching and fitting. 
     
    """
    COLNAMES = REFCOL_PARS
    IN_UNITS = 'degrees'
    
    def generateXY(self):
        pass
    def generateRaDec(self):
        if isinstance(self.source,list):
            self.radec = self.source
        else:
            self.radec = self._readCatalog()    
